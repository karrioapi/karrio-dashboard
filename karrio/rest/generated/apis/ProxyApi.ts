/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2022.8.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorMessages,
  ErrorResponse,
  OperationResponse,
  PickupCancelRequest,
  PickupRequest,
  PickupResponse,
  PickupUpdateRequest,
  RateRequest,
  RateResponse,
  ShipmentCancelRequest,
  ShippingRequest,
  ShippingResponse,
  TrackingData,
  TrackingResponse,
} from '../models';
import {
    ErrorMessagesFromJSON,
    ErrorMessagesToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    OperationResponseFromJSON,
    OperationResponseToJSON,
    PickupCancelRequestFromJSON,
    PickupCancelRequestToJSON,
    PickupRequestFromJSON,
    PickupRequestToJSON,
    PickupResponseFromJSON,
    PickupResponseToJSON,
    PickupUpdateRequestFromJSON,
    PickupUpdateRequestToJSON,
    RateRequestFromJSON,
    RateRequestToJSON,
    RateResponseFromJSON,
    RateResponseToJSON,
    ShipmentCancelRequestFromJSON,
    ShipmentCancelRequestToJSON,
    ShippingRequestFromJSON,
    ShippingRequestToJSON,
    ShippingResponseFromJSON,
    ShippingResponseToJSON,
    TrackingDataFromJSON,
    TrackingDataToJSON,
    TrackingResponseFromJSON,
    TrackingResponseToJSON,
} from '../models';

export interface BuyLabelRequest {
    shippingRequest: ShippingRequest;
}

export interface CancelPickupRequest {
    carrierName: CancelPickupCarrierNameEnum;
    pickupCancelRequest: PickupCancelRequest;
}

export interface FetchRatesRequest {
    rateRequest: RateRequest;
}

export interface GetTrackingRequest {
    trackingData: TrackingData;
    hub?: string;
}

export interface SchedulePickupRequest {
    carrierName: SchedulePickupCarrierNameEnum;
    pickupRequest: PickupRequest;
}

export interface TrackShipmentRequest {
    carrierName: TrackShipmentCarrierNameEnum;
    trackingNumber: string;
    hub?: string;
}

export interface UpdatePickupRequest {
    carrierName: UpdatePickupCarrierNameEnum;
    pickupUpdateRequest: PickupUpdateRequest;
}

export interface VoidLabelRequest {
    carrierName: VoidLabelCarrierNameEnum;
    shipmentCancelRequest: ShipmentCancelRequest;
}

/**
 * 
 */
export class ProxyApi extends runtime.BaseAPI {

    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * Buy a shipment label
     */
    async buyLabelRaw(requestParameters: BuyLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShippingResponse>> {
        if (requestParameters.shippingRequest === null || requestParameters.shippingRequest === undefined) {
            throw new runtime.RequiredError('shippingRequest','Required parameter requestParameters.shippingRequest was null or undefined when calling buyLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/shipping`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShippingRequestToJSON(requestParameters.shippingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShippingResponseFromJSON(jsonValue));
    }

    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * Buy a shipment label
     */
    async buyLabel(requestParameters: BuyLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShippingResponse> {
        const response = await this.buyLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel a pickup previously scheduled
     * Cancel a pickup
     */
    async cancelPickupRaw(requestParameters: CancelPickupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperationResponse>> {
        if (requestParameters.carrierName === null || requestParameters.carrierName === undefined) {
            throw new runtime.RequiredError('carrierName','Required parameter requestParameters.carrierName was null or undefined when calling cancelPickup.');
        }

        if (requestParameters.pickupCancelRequest === null || requestParameters.pickupCancelRequest === undefined) {
            throw new runtime.RequiredError('pickupCancelRequest','Required parameter requestParameters.pickupCancelRequest was null or undefined when calling cancelPickup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/pickups/{carrier_name}/cancel`.replace(`{${"carrier_name"}}`, encodeURIComponent(String(requestParameters.carrierName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PickupCancelRequestToJSON(requestParameters.pickupCancelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OperationResponseFromJSON(jsonValue));
    }

    /**
     * Cancel a pickup previously scheduled
     * Cancel a pickup
     */
    async cancelPickup(requestParameters: CancelPickupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperationResponse> {
        const response = await this.cancelPickupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * Fetch shipment rates
     */
    async fetchRatesRaw(requestParameters: FetchRatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RateResponse>> {
        if (requestParameters.rateRequest === null || requestParameters.rateRequest === undefined) {
            throw new runtime.RequiredError('rateRequest','Required parameter requestParameters.rateRequest was null or undefined when calling fetchRates.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/rates`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RateRequestToJSON(requestParameters.rateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RateResponseFromJSON(jsonValue));
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * Fetch shipment rates
     */
    async fetchRates(requestParameters: FetchRatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RateResponse> {
        const response = await this.fetchRatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * Get tracking details
     */
    async getTrackingRaw(requestParameters: GetTrackingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TrackingResponse>> {
        if (requestParameters.trackingData === null || requestParameters.trackingData === undefined) {
            throw new runtime.RequiredError('trackingData','Required parameter requestParameters.trackingData was null or undefined when calling getTracking.');
        }

        const queryParameters: any = {};

        if (requestParameters.hub !== undefined) {
            queryParameters['hub'] = requestParameters.hub;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/tracking`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TrackingDataToJSON(requestParameters.trackingData),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TrackingResponseFromJSON(jsonValue));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * Get tracking details
     */
    async getTracking(requestParameters: GetTrackingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TrackingResponse> {
        const response = await this.getTrackingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Schedule one or many parcels pickup
     * Schedule a pickup
     */
    async schedulePickupRaw(requestParameters: SchedulePickupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PickupResponse>> {
        if (requestParameters.carrierName === null || requestParameters.carrierName === undefined) {
            throw new runtime.RequiredError('carrierName','Required parameter requestParameters.carrierName was null or undefined when calling schedulePickup.');
        }

        if (requestParameters.pickupRequest === null || requestParameters.pickupRequest === undefined) {
            throw new runtime.RequiredError('pickupRequest','Required parameter requestParameters.pickupRequest was null or undefined when calling schedulePickup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/pickups/{carrier_name}`.replace(`{${"carrier_name"}}`, encodeURIComponent(String(requestParameters.carrierName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PickupRequestToJSON(requestParameters.pickupRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PickupResponseFromJSON(jsonValue));
    }

    /**
     * Schedule one or many parcels pickup
     * Schedule a pickup
     */
    async schedulePickup(requestParameters: SchedulePickupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PickupResponse> {
        const response = await this.schedulePickupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * Track a shipment
     */
    async trackShipmentRaw(requestParameters: TrackShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TrackingResponse>> {
        if (requestParameters.carrierName === null || requestParameters.carrierName === undefined) {
            throw new runtime.RequiredError('carrierName','Required parameter requestParameters.carrierName was null or undefined when calling trackShipment.');
        }

        if (requestParameters.trackingNumber === null || requestParameters.trackingNumber === undefined) {
            throw new runtime.RequiredError('trackingNumber','Required parameter requestParameters.trackingNumber was null or undefined when calling trackShipment.');
        }

        const queryParameters: any = {};

        if (requestParameters.hub !== undefined) {
            queryParameters['hub'] = requestParameters.hub;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/tracking/{tracking_number}`.replace(`{${"carrier_name"}}`, encodeURIComponent(String(requestParameters.carrierName))).replace(`{${"tracking_number"}}`, encodeURIComponent(String(requestParameters.trackingNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TrackingResponseFromJSON(jsonValue));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * Track a shipment
     */
    async trackShipment(requestParameters: TrackShipmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TrackingResponse> {
        const response = await this.trackShipmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify a scheduled pickup
     * Update a pickup
     */
    async updatePickupRaw(requestParameters: UpdatePickupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PickupResponse>> {
        if (requestParameters.carrierName === null || requestParameters.carrierName === undefined) {
            throw new runtime.RequiredError('carrierName','Required parameter requestParameters.carrierName was null or undefined when calling updatePickup.');
        }

        if (requestParameters.pickupUpdateRequest === null || requestParameters.pickupUpdateRequest === undefined) {
            throw new runtime.RequiredError('pickupUpdateRequest','Required parameter requestParameters.pickupUpdateRequest was null or undefined when calling updatePickup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/pickups/{carrier_name}/update`.replace(`{${"carrier_name"}}`, encodeURIComponent(String(requestParameters.carrierName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PickupUpdateRequestToJSON(requestParameters.pickupUpdateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PickupResponseFromJSON(jsonValue));
    }

    /**
     * Modify a scheduled pickup
     * Update a pickup
     */
    async updatePickup(requestParameters: UpdatePickupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PickupResponse> {
        const response = await this.updatePickupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancel a shipment and the label previously created
     * Void a shipment label
     */
    async voidLabelRaw(requestParameters: VoidLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperationResponse>> {
        if (requestParameters.carrierName === null || requestParameters.carrierName === undefined) {
            throw new runtime.RequiredError('carrierName','Required parameter requestParameters.carrierName was null or undefined when calling voidLabel.');
        }

        if (requestParameters.shipmentCancelRequest === null || requestParameters.shipmentCancelRequest === undefined) {
            throw new runtime.RequiredError('shipmentCancelRequest','Required parameter requestParameters.shipmentCancelRequest was null or undefined when calling voidLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/proxy/shipping/{carrier_name}/cancel`.replace(`{${"carrier_name"}}`, encodeURIComponent(String(requestParameters.carrierName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShipmentCancelRequestToJSON(requestParameters.shipmentCancelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OperationResponseFromJSON(jsonValue));
    }

    /**
     * Cancel a shipment and the label previously created
     * Void a shipment label
     */
    async voidLabel(requestParameters: VoidLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperationResponse> {
        const response = await this.voidLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CancelPickupCarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;
export type CancelPickupCarrierNameEnum = typeof CancelPickupCarrierNameEnum[keyof typeof CancelPickupCarrierNameEnum];
/**
 * @export
 */
export const SchedulePickupCarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;
export type SchedulePickupCarrierNameEnum = typeof SchedulePickupCarrierNameEnum[keyof typeof SchedulePickupCarrierNameEnum];
/**
 * @export
 */
export const TrackShipmentCarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Fedex: 'fedex',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;
export type TrackShipmentCarrierNameEnum = typeof TrackShipmentCarrierNameEnum[keyof typeof TrackShipmentCarrierNameEnum];
/**
 * @export
 */
export const UpdatePickupCarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;
export type UpdatePickupCarrierNameEnum = typeof UpdatePickupCarrierNameEnum[keyof typeof UpdatePickupCarrierNameEnum];
/**
 * @export
 */
export const VoidLabelCarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;
export type VoidLabelCarrierNameEnum = typeof VoidLabelCarrierNameEnum[keyof typeof VoidLabelCarrierNameEnum];
