/* tslint:disable */
/* eslint-disable */
/**
 * Karrio API
 *  ## API Reference  Karrio is an open source multi-carrier shipping API that simplifies the integration of logistic carrier services.  The Karrio API is organized around REST. Our API has predictable resource-oriented URLs, accepts JSON-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  The Karrio API differs for every account as we release new versions. These docs are customized to your version of the API.   ## Versioning  When backwards-incompatible changes are made to the API, a new, dated version is released. The current version is `2022.8.14`.  Read our API changelog and to learn more about backwards compatibility.  As a precaution, use API versioning to check a new API version before committing to an upgrade.   ## Environments  The Karrio API offer the possibility to create and retrieve certain objects in `test_mode`. In development, it is therefore possible to add carrier connections, get live rates, buy labels, create trackers and schedule pickups in `test_mode`.   ## Pagination  All top-level API resources have support for bulk fetches via \"list\" API methods. For instance, you can list addresses, list shipments, and list trackers. These list API methods share a common structure, taking at least these two parameters: limit, and offset.  Karrio utilizes offset-based pagination via the offset and limit parameters. Both parameters take a number as value (see below) and return objects in reverse chronological order. The offset parameter returns objects listed after an index. The limit parameter take a limit on the number of objects to be returned from 1 to 100.   ```json {     \"count\": 100,     \"next\": \"/v1/shipments?limit=25&offset=50\",     \"previous\": \"/v1/shipments?limit=25&offset=25\",     \"results\": [         { ... },     ] } ```  ## Metadata  Updateable Karrio objects—including Shipment and Order—have a metadata parameter. You can use this parameter to attach key-value data to these Karrio objects.  Metadata is useful for storing additional, structured information on an object. As an example, you could store your user\'s full name and corresponding unique identifier from your system on a Karrio Order object.  Do not store any sensitive information as metadata.  ## Authentication  API keys are used to authenticate requests. You can view and manage your API keys in the Dashboard.  Your API keys carry many privileges, so be sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as GitHub, client-side code, and so forth.  Authentication to the API is performed via HTTP Basic Auth. Provide your API token as the basic auth username value. You do not need to provide a password.  ```shell $ curl https://instance.api.com/v1/shipments \\     -u key_xxxxxx: # The colon prevents curl from asking for a password. ```  If you need to authenticate via bearer auth (e.g., for a cross-origin request), use `-H \"Authorization: Token key_xxxxxx\"` instead of `-u key_xxxxxx`.  All API requests must be made over [HTTPS](http://en.wikipedia.org/wiki/HTTP_Secure). API requests without authentication will also fail.  
 *
 * The version of the OpenAPI document: 2022.8.14
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * The list of API errors
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * The error or warning message
     * @type {string}
     * @memberof APIError
     */
    'message'?: string;
    /**
     * The message code
     * @type {string}
     * @memberof APIError
     */
    'code'?: string;
    /**
     * any additional details
     * @type {{ [key: string]: string; }}
     * @memberof APIError
     */
    'details'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Address
     */
    'id'?: string;
    /**
     *  The address postal code  **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    'postal_code'?: string | null;
    /**
     *  The address city.  **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof Address
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof Address
     */
    'state_tax_id'?: string | null;
    /**
     *  attention to  **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof Address
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof Address
     */
    'country_code': AddressCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof Address
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof Address
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof Address
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof Address
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof Address
     */
    'residential'?: boolean | null;
    /**
     *  The address line with street number <br/> **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof Address
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof Address
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Address
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof Address
     */
    'validation'?: AddressValidation | null;
}

export const AddressCountryCodeEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type AddressCountryCodeEnum = typeof AddressCountryCodeEnum[keyof typeof AddressCountryCodeEnum];

/**
 * 
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     *  The address postal code  **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    'postal_code'?: string | null;
    /**
     *  The address city.  **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof AddressData
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof AddressData
     */
    'state_tax_id'?: string | null;
    /**
     *  attention to  **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof AddressData
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof AddressData
     */
    'country_code': AddressDataCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof AddressData
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof AddressData
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof AddressData
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof AddressData
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof AddressData
     */
    'residential'?: boolean | null;
    /**
     *  The address line with street number <br/> **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof AddressData
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof AddressData
     */
    'validate_location'?: boolean | null;
}

export const AddressDataCountryCodeEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type AddressDataCountryCodeEnum = typeof AddressDataCountryCodeEnum[keyof typeof AddressDataCountryCodeEnum];

/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * 
     * @type {number}
     * @memberof AddressList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Address>}
     * @memberof AddressList
     */
    'results': Array<Address>;
}
/**
 * Specify address validation result
 * @export
 * @interface AddressValidation
 */
export interface AddressValidation {
    /**
     * True if the address is valid
     * @type {boolean}
     * @memberof AddressValidation
     */
    'success': boolean;
    /**
     * validation service details
     * @type {object}
     * @memberof AddressValidation
     */
    'meta'?: object | null;
}
/**
 * 
 * @export
 * @interface BatchObject
 */
export interface BatchObject {
    /**
     * A unique identifier
     * @type {string}
     * @memberof BatchObject
     */
    'id'?: string;
    /**
     * The batch operation resource status
     * @type {string}
     * @memberof BatchObject
     */
    'status': BatchObjectStatusEnum;
}

export const BatchObjectStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type BatchObjectStatusEnum = typeof BatchObjectStatusEnum[keyof typeof BatchObjectStatusEnum];

/**
 * 
 * @export
 * @interface BatchOperation
 */
export interface BatchOperation {
    /**
     * A unique identifier
     * @type {string}
     * @memberof BatchOperation
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'status': BatchOperationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'resource_type': BatchOperationResourceTypeEnum;
    /**
     * 
     * @type {Array<BatchObject>}
     * @memberof BatchOperation
     */
    'resources': Array<BatchObject>;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof BatchOperation
     */
    'test_mode': boolean;
}

export const BatchOperationStatusEnum = {
    Queued: 'queued',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type BatchOperationStatusEnum = typeof BatchOperationStatusEnum[keyof typeof BatchOperationStatusEnum];
export const BatchOperationResourceTypeEnum = {
    Order: 'order',
    Shipment: 'shipment',
    Tracking: 'tracking',
    Billing: 'billing'
} as const;

export type BatchOperationResourceTypeEnum = typeof BatchOperationResourceTypeEnum[keyof typeof BatchOperationResourceTypeEnum];

/**
 * 
 * @export
 * @interface BatchOperations
 */
export interface BatchOperations {
    /**
     * 
     * @type {number}
     * @memberof BatchOperations
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchOperations
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchOperations
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BatchOperation>}
     * @memberof BatchOperations
     */
    'results': Array<BatchOperation>;
}
/**
 * 
 * @export
 * @interface CarrierList
 */
export interface CarrierList {
    /**
     * 
     * @type {number}
     * @memberof CarrierList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CarrierList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CarrierList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CarrierSettings>}
     * @memberof CarrierList
     */
    'results': Array<CarrierSettings>;
}
/**
 * 
 * @export
 * @interface CarrierSettings
 */
export interface CarrierSettings {
    /**
     * A unique address identifier
     * @type {string}
     * @memberof CarrierSettings
     */
    'id': string;
    /**
     * Indicates a carrier (type)
     * @type {string}
     * @memberof CarrierSettings
     */
    'carrier_name': CarrierSettingsCarrierNameEnum;
    /**
     * Indicates a specific carrier configuration name.
     * @type {string}
     * @memberof CarrierSettings
     */
    'carrier_id': string;
    /**
     *  The test flag indicates whether to use a carrier configured for test. 
     * @type {boolean}
     * @memberof CarrierSettings
     */
    'test_mode': boolean;
    /**
     *  The active flag indicates whether the carrier account is active or not. 
     * @type {boolean}
     * @memberof CarrierSettings
     */
    'active': boolean;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof CarrierSettings
     */
    'object_type'?: string;
}

export const CarrierSettingsCarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;

export type CarrierSettingsCarrierNameEnum = typeof CarrierSettingsCarrierNameEnum[keyof typeof CarrierSettingsCarrierNameEnum];

/**
 * list of the rate\'s additional charges
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * The charge description
     * @type {string}
     * @memberof Charge
     */
    'name'?: string | null;
    /**
     * The charge monetary value
     * @type {number}
     * @memberof Charge
     */
    'amount'?: number | null;
    /**
     * The charge amount currency
     * @type {string}
     * @memberof Charge
     */
    'currency'?: string | null;
}
/**
 * The parcel content items
 * @export
 * @interface Commodity
 */
export interface Commodity {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Commodity
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof Commodity
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof Commodity
     */
    'weight_unit': CommodityWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof Commodity
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof Commodity
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof Commodity
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof Commodity
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof Commodity
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof Commodity
     */
    'value_currency'?: CommodityValueCurrencyEnum;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof Commodity
     */
    'origin_country'?: CommodityOriginCountryEnum;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof Commodity
     */
    'parent_id'?: string | null;
    /**
     *  <details> <summary>Commodity user references metadata.</summary>  ``` {     \"part_number\": \"5218487281\",     \"reference1\": \"# ref 1\",     \"reference2\": \"# ref 2\",     \"reference3\": \"# ref 3\",     \"reference4\": \"# ref 4\",     ... } ``` </details> 
     * @type {object}
     * @memberof Commodity
     */
    'metadata'?: object | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Commodity
     */
    'object_type'?: string;
}

export const CommodityWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB'
} as const;

export type CommodityWeightUnitEnum = typeof CommodityWeightUnitEnum[keyof typeof CommodityWeightUnitEnum];
export const CommodityValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type CommodityValueCurrencyEnum = typeof CommodityValueCurrencyEnum[keyof typeof CommodityValueCurrencyEnum];
export const CommodityOriginCountryEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type CommodityOriginCountryEnum = typeof CommodityOriginCountryEnum[keyof typeof CommodityOriginCountryEnum];

/**
 * The parcel content items
 * @export
 * @interface CommodityData
 */
export interface CommodityData {
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof CommodityData
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof CommodityData
     */
    'weight_unit': CommodityDataWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof CommodityData
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof CommodityData
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof CommodityData
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof CommodityData
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof CommodityData
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof CommodityData
     */
    'value_currency'?: CommodityDataValueCurrencyEnum;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof CommodityData
     */
    'origin_country'?: CommodityDataOriginCountryEnum;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof CommodityData
     */
    'parent_id'?: string | null;
    /**
     *  <details> <summary>Commodity user references metadata.</summary>  ``` {     \"part_number\": \"5218487281\",     \"reference1\": \"# ref 1\",     \"reference2\": \"# ref 2\",     \"reference3\": \"# ref 3\",     \"reference4\": \"# ref 4\",     ... } ``` </details> 
     * @type {object}
     * @memberof CommodityData
     */
    'metadata'?: object | null;
}

export const CommodityDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB'
} as const;

export type CommodityDataWeightUnitEnum = typeof CommodityDataWeightUnitEnum[keyof typeof CommodityDataWeightUnitEnum];
export const CommodityDataValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type CommodityDataValueCurrencyEnum = typeof CommodityDataValueCurrencyEnum[keyof typeof CommodityDataValueCurrencyEnum];
export const CommodityDataOriginCountryEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type CommodityDataOriginCountryEnum = typeof CommodityDataOriginCountryEnum[keyof typeof CommodityDataOriginCountryEnum];

/**
 * 
 * @export
 * @interface Customs
 */
export interface Customs {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Customs
     */
    'id'?: string;
    /**
     * The parcel content items
     * @type {Array<Commodity>}
     * @memberof Customs
     */
    'commodities'?: Array<Commodity>;
    /**
     * 
     * @type {Duty}
     * @memberof Customs
     */
    'duty'?: Duty | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'content_type'?: CustomsContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'content_description'?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     * @type {string}
     * @memberof Customs
     */
    'incoterm'?: CustomsIncotermEnum;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof Customs
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof Customs
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof Customs
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof Customs
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'signer'?: string | null;
    /**
     *  <details> <summary>Customs identification options.</summary>  ``` {     \"aes\": \"5218487281\",     \"eel_pfc\": \"5218487281\",     \"license_number\": \"5218487281\",     \"certificate_number\": \"5218487281\",     \"nip_number\": \"5218487281\",     \"eori_number\": \"5218487281\",     \"vat_registration_number\": \"5218487281\", } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof Customs
     */
    'options'?: object;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Customs
     */
    'object_type'?: string;
}

export const CustomsContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other'
} as const;

export type CustomsContentTypeEnum = typeof CustomsContentTypeEnum[keyof typeof CustomsContentTypeEnum];
export const CustomsIncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB'
} as const;

export type CustomsIncotermEnum = typeof CustomsIncotermEnum[keyof typeof CustomsIncotermEnum];

/**
 * 
 * @export
 * @interface CustomsData
 */
export interface CustomsData {
    /**
     * The parcel content items
     * @type {Array<CommodityData>}
     * @memberof CustomsData
     */
    'commodities': Array<CommodityData>;
    /**
     * 
     * @type {Duty}
     * @memberof CustomsData
     */
    'duty'?: Duty | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'content_type'?: CustomsDataContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'content_description'?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     * @type {string}
     * @memberof CustomsData
     */
    'incoterm'?: CustomsDataIncotermEnum;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof CustomsData
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof CustomsData
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof CustomsData
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof CustomsData
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'signer'?: string | null;
    /**
     *  <details> <summary>Customs identification options.</summary>  ``` {     \"aes\": \"5218487281\",     \"eel_pfc\": \"5218487281\",     \"license_number\": \"5218487281\",     \"certificate_number\": \"5218487281\",     \"nip_number\": \"5218487281\",     \"eori_number\": \"5218487281\",     \"vat_registration_number\": \"5218487281\", } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof CustomsData
     */
    'options'?: object;
}

export const CustomsDataContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other'
} as const;

export type CustomsDataContentTypeEnum = typeof CustomsDataContentTypeEnum[keyof typeof CustomsDataContentTypeEnum];
export const CustomsDataIncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB'
} as const;

export type CustomsDataIncotermEnum = typeof CustomsDataIncotermEnum[keyof typeof CustomsDataIncotermEnum];

/**
 * 
 * @export
 * @interface CustomsList
 */
export interface CustomsList {
    /**
     * 
     * @type {number}
     * @memberof CustomsList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Customs>}
     * @memberof CustomsList
     */
    'results': Array<Customs>;
}
/**
 * 
 * @export
 * @interface Data200Response
 */
export interface Data200Response {
    /**
     * 
     * @type {string}
     * @memberof Data200Response
     */
    'VERSION'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data200Response
     */
    'APP_NAME'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data200Response
     */
    'APP_WEBSITE'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'AUDIT_LOGGING'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'ALLOW_SIGNUP'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'ALLOW_ADMIN_APPROVED_SIGNUP'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'ALLOW_MULTI_ACCOUNT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'MULTI_ORGANIZATIONS'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'ORDERS_MANAGEMENT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'APPS_MANAGEMENT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'DOCUMENTS_MANAGEMENT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'DATA_IMPORT_EXPORT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'CUSTOM_CARRIER_DEFINITION'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Data200Response
     */
    'PERSIST_SDK_TRACING'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Data200Response
     */
    'ADMIN'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data200Response
     */
    'OPENAPI'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data200Response
     */
    'GRAPHQL'?: string;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'ADDRESS_AUTO_COMPLETE'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'countries'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'currencies'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'carriers'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'custom_carriers'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'customs_content_type'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'incoterms'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'states'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'services'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'service_names'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'options'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'option_names'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'package_presets'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'packaging_types'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'payment_types'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'carrier_capabilities'?: object;
    /**
     * 
     * @type {object}
     * @memberof Data200Response
     */
    'service_levels'?: object;
}
/**
 * the carrier shipping document ids
 * @export
 * @interface DocumentDetails
 */
export interface DocumentDetails {
    /**
     * The uploaded document id.
     * @type {string}
     * @memberof DocumentDetails
     */
    'document_id'?: string;
    /**
     * The uploaded document file name.
     * @type {string}
     * @memberof DocumentDetails
     */
    'file_name'?: string;
}
/**
 * Shipping document files
 * @export
 * @interface DocumentFileData
 */
export interface DocumentFileData {
    /**
     * A base64 file to upload
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_file': string;
    /**
     * A file name
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_name': string;
    /**
     * Shipping document type
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_type'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentUploadData
 */
export interface DocumentUploadData {
    /**
     * The documents related shipment.
     * @type {string}
     * @memberof DocumentUploadData
     */
    'shipment_id': string;
    /**
     * Shipping document files
     * @type {Array<DocumentFileData>}
     * @memberof DocumentUploadData
     */
    'document_files': Array<DocumentFileData>;
    /**
     * Shipping document file reference
     * @type {string}
     * @memberof DocumentUploadData
     */
    'reference'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentUploadRecord
 */
export interface DocumentUploadRecord {
    /**
     * A unique identifier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'id'?: string;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'carrier_id'?: string | null;
    /**
     * the carrier shipping document ids
     * @type {Array<DocumentDetails>}
     * @memberof DocumentUploadRecord
     */
    'documents'?: Array<DocumentDetails>;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof DocumentUploadRecord
     */
    'meta'?: object | null;
    /**
     * Shipping document file reference
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'reference'?: string | null;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof DocumentUploadRecord
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface DocumentUploadRecords
 */
export interface DocumentUploadRecords {
    /**
     * 
     * @type {number}
     * @memberof DocumentUploadRecords
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadRecords
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadRecords
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DocumentUploadRecord>}
     * @memberof DocumentUploadRecords
     */
    'results': Array<DocumentUploadRecord>;
}
/**
 * The shipment documents
 * @export
 * @interface Documents
 */
export interface Documents {
    /**
     * The shipment label in base64 string
     * @type {string}
     * @memberof Documents
     */
    'label'?: string | null;
    /**
     * The shipment invoice in base64 string
     * @type {string}
     * @memberof Documents
     */
    'invoice'?: string | null;
}
/**
 *  The payment details.<br/> Note that this is required for a Dutiable parcel shipped internationally. 
 * @export
 * @interface Duty
 */
export interface Duty {
    /**
     * The duty payer
     * @type {string}
     * @memberof Duty
     */
    'paid_by'?: DutyPaidByEnum;
    /**
     * The declared value currency
     * @type {string}
     * @memberof Duty
     */
    'currency'?: DutyCurrencyEnum;
    /**
     * The package declared value
     * @type {number}
     * @memberof Duty
     */
    'declared_value'?: number | null;
    /**
     * The duty payment account number
     * @type {string}
     * @memberof Duty
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Duty
     */
    'bill_to'?: Address;
}

export const DutyPaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party'
} as const;

export type DutyPaidByEnum = typeof DutyPaidByEnum[keyof typeof DutyPaidByEnum];
export const DutyCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type DutyCurrencyEnum = typeof DutyCurrencyEnum[keyof typeof DutyCurrencyEnum];

/**
 * 
 * @export
 * @interface ErrorMessages
 */
export interface ErrorMessages {
    /**
     * The list of error messages
     * @type {Array<Message>}
     * @memberof ErrorMessages
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The list of API errors
     * @type {Array<APIError>}
     * @memberof ErrorResponse
     */
    'errors'?: Array<APIError>;
}
/**
 * The order line items.
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * A unique identifier
     * @type {string}
     * @memberof LineItem
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof LineItem
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof LineItem
     */
    'weight_unit': LineItemWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof LineItem
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof LineItem
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof LineItem
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof LineItem
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof LineItem
     */
    'value_amount'?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof LineItem
     */
    'value_currency'?: LineItemValueCurrencyEnum;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof LineItem
     */
    'origin_country'?: LineItemOriginCountryEnum;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof LineItem
     */
    'parent_id'?: string | null;
    /**
     *  <details> <summary>Commodity user references metadata.</summary>  ``` {     \"part_number\": \"5218487281\",     \"reference1\": \"# ref 1\",     \"reference2\": \"# ref 2\",     \"reference3\": \"# ref 3\",     \"reference4\": \"# ref 4\",     ... } ``` </details> 
     * @type {object}
     * @memberof LineItem
     */
    'metadata'?: object | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof LineItem
     */
    'object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'unfulfilled_quantity'?: number;
}

export const LineItemWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB'
} as const;

export type LineItemWeightUnitEnum = typeof LineItemWeightUnitEnum[keyof typeof LineItemWeightUnitEnum];
export const LineItemValueCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type LineItemValueCurrencyEnum = typeof LineItemValueCurrencyEnum[keyof typeof LineItemValueCurrencyEnum];
export const LineItemOriginCountryEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type LineItemOriginCountryEnum = typeof LineItemOriginCountryEnum[keyof typeof LineItemOriginCountryEnum];

/**
 * The list of note or warning messages
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The error or warning message
     * @type {string}
     * @memberof Message
     */
    'message'?: string;
    /**
     * The message code
     * @type {string}
     * @memberof Message
     */
    'code'?: string;
    /**
     * any additional details
     * @type {{ [key: string]: string; }}
     * @memberof Message
     */
    'details'?: { [key: string]: string; };
    /**
     * The targeted carrier
     * @type {string}
     * @memberof Message
     */
    'carrier_name'?: string;
    /**
     * The targeted carrier name (unique identifier)
     * @type {string}
     * @memberof Message
     */
    'carrier_id'?: string;
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * Operation performed
     * @type {string}
     * @memberof Operation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof Operation
     */
    'success': boolean;
}
/**
 * The operation details
 * @export
 * @interface OperationConfirmation
 */
export interface OperationConfirmation {
    /**
     * Operation performed
     * @type {string}
     * @memberof OperationConfirmation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof OperationConfirmation
     */
    'success': boolean;
    /**
     * The operation carrier
     * @type {string}
     * @memberof OperationConfirmation
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof OperationConfirmation
     */
    'carrier_id': string;
}
/**
 * 
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof OperationResponse
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {OperationConfirmation}
     * @memberof OperationResponse
     */
    'confirmation'?: OperationConfirmation;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Order
     */
    'object_type'?: string;
    /**
     * The source\' order id.
     * @type {string}
     * @memberof Order
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     * @type {string}
     * @memberof Order
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.
     * @type {string}
     * @memberof Order
     */
    'source'?: string;
    /**
     * The order status.
     * @type {string}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    'shipping_to': Address;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    'shipping_from'?: Address;
    /**
     * 
     * @type {AddressData}
     * @memberof Order
     */
    'billing_address'?: AddressData;
    /**
     * The order line items.
     * @type {Array<LineItem>}
     * @memberof Order
     */
    'line_items': Array<LineItem>;
    /**
     *  <details> <summary>The options available for the order shipments.</summary>  ``` {     \"currency\": \"USD\",     \"paid_by\": \"third_party\",     \"payment_account_number\": \"123456789\",     \"duty_paid_by\": \"third_party\",     \"duty_account_number\": \"123456789\",     \"invoice_number\": \"123456789\",     \"invoice_date\": \"2020-01-01\",     \"single_item_per_parcel\": true,     \"carrier_ids\": [\"canadapost-test\"], } ```  Please check the docs for shipment specific options. </details> 
     * @type {object}
     * @memberof Order
     */
    'options'?: object | null;
    /**
     * User metadata for the order.
     * @type {object}
     * @memberof Order
     */
    'metadata'?: object;
    /**
     * The shipments associated with the order.
     * @type {Array<Shipment>}
     * @memberof Order
     */
    'shipments'?: Array<Shipment>;
    /**
     * Specify whether the order is in test mode or not.
     * @type {boolean}
     * @memberof Order
     */
    'test_mode': boolean;
    /**
     *  The shipment creation datetime  Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz` 
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
}

export const OrderStatusEnum = {
    Unfulfilled: 'unfulfilled',
    Cancelled: 'cancelled',
    Fulfilled: 'fulfilled',
    Delivered: 'delivered',
    Partial: 'partial'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];

/**
 * 
 * @export
 * @interface OrderData
 */
export interface OrderData {
    /**
     * The source\' order id.
     * @type {string}
     * @memberof OrderData
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     * @type {string}
     * @memberof OrderData
     */
    'order_date'?: string | null;
    /**
     *  The order\'s source.  e.g. API, POS, ERP, Shopify, Woocommerce, etc. 
     * @type {string}
     * @memberof OrderData
     */
    'source'?: string;
    /**
     * 
     * @type {AddressData}
     * @memberof OrderData
     */
    'shipping_to': AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof OrderData
     */
    'shipping_from'?: AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof OrderData
     */
    'billing_address'?: AddressData;
    /**
     * The order line items.
     * @type {Array<CommodityData>}
     * @memberof OrderData
     */
    'line_items': Array<CommodityData>;
    /**
     *  <details> <summary>The options available for the order shipments.</summary>  ``` {     \"currency\": \"USD\",     \"paid_by\": \"third_party\",     \"payment_account_number\": \"123456789\",     \"duty_paid_by\": \"third_party\",     \"duty_account_number\": \"123456789\",     \"invoice_number\": \"123456789\",     \"invoice_date\": \"2020-01-01\",     \"single_item_per_parcel\": true,     \"carrier_ids\": [\"canadapost-test\"], } ```  Please check the docs for shipment specific options. </details> 
     * @type {object}
     * @memberof OrderData
     */
    'options'?: object | null;
    /**
     * User metadata for the order.
     * @type {object}
     * @memberof OrderData
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface OrderList
 */
export interface OrderList {
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderList
     */
    'results': Array<Order>;
}
/**
 * 
 * @export
 * @interface OrderUpdateData
 */
export interface OrderUpdateData {
    /**
     *  <details> <summary>The options available for the order shipments.</summary>  ``` {     \"currency\": \"USD\",     \"paid_by\": \"third_party\",     \"payment_account_number\": \"123456789\",     \"duty_paid_by\": \"recipient\",     \"duty_account_number\": \"123456789\",     \"invoice_number\": \"123456789\",     \"invoice_date\": \"2020-01-01\",     \"single_item_per_parcel\": true,     \"carrier_ids\": [\"canadapost-test\"], } ```  Please check the docs for shipment specific options. </details> 
     * @type {object}
     * @memberof OrderUpdateData
     */
    'options'?: object | null;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof OrderUpdateData
     */
    'metadata'?: object;
}
/**
 * The shipment\'s parcels
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Parcel
     */
    'id'?: string;
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof Parcel
     */
    'weight': number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof Parcel
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof Parcel
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof Parcel
     */
    'length'?: number | null;
    /**
     *  The parcel\'s packaging type.  **Note that the packaging is optional when using a package preset**  values: <br/> `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`  For carrier specific packaging types, please consult the reference. 
     * @type {string}
     * @memberof Parcel
     */
    'packaging_type'?: string | null;
    /**
     *  The parcel\'s package preset.  For carrier specific package presets, please consult the reference. 
     * @type {string}
     * @memberof Parcel
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof Parcel
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof Parcel
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof Parcel
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof Parcel
     */
    'weight_unit': ParcelWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof Parcel
     */
    'dimension_unit'?: ParcelDimensionUnitEnum;
    /**
     * The parcel items.
     * @type {Array<Commodity>}
     * @memberof Parcel
     */
    'items'?: Array<Commodity>;
    /**
     * The parcel reference number. (can be used as tracking number for custom carriers)
     * @type {string}
     * @memberof Parcel
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof Parcel
     */
    'freight_class'?: string | null;
    /**
     *  <details> <summary>Parcel specific options.</summary>  ``` {     \"insurance\": \"100.00\",     \"insured_by\": \"carrier\", } ```  Please check the docs for more details. </details> 
     * @type {object}
     * @memberof Parcel
     */
    'options'?: object;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Parcel
     */
    'object_type'?: string;
}

export const ParcelWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB'
} as const;

export type ParcelWeightUnitEnum = typeof ParcelWeightUnitEnum[keyof typeof ParcelWeightUnitEnum];
export const ParcelDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN'
} as const;

export type ParcelDimensionUnitEnum = typeof ParcelDimensionUnitEnum[keyof typeof ParcelDimensionUnitEnum];

/**
 * 
 * @export
 * @interface ParcelData
 */
export interface ParcelData {
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof ParcelData
     */
    'weight': number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof ParcelData
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof ParcelData
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof ParcelData
     */
    'length'?: number | null;
    /**
     *  The parcel\'s packaging type.  **Note that the packaging is optional when using a package preset**  values: <br/> `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`  For carrier specific packaging types, please consult the reference. 
     * @type {string}
     * @memberof ParcelData
     */
    'packaging_type'?: string | null;
    /**
     *  The parcel\'s package preset.  For carrier specific package presets, please consult the reference. 
     * @type {string}
     * @memberof ParcelData
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof ParcelData
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof ParcelData
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof ParcelData
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof ParcelData
     */
    'weight_unit': ParcelDataWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof ParcelData
     */
    'dimension_unit'?: ParcelDataDimensionUnitEnum;
    /**
     * The parcel items.
     * @type {Array<CommodityData>}
     * @memberof ParcelData
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number. (can be used as tracking number for custom carriers)
     * @type {string}
     * @memberof ParcelData
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof ParcelData
     */
    'freight_class'?: string | null;
    /**
     *  <details> <summary>Parcel specific options.</summary>  ``` {     \"insurance\": \"100.00\",     \"insured_by\": \"carrier\", } ```  Please check the docs for more details. </details> 
     * @type {object}
     * @memberof ParcelData
     */
    'options'?: object;
}

export const ParcelDataWeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB'
} as const;

export type ParcelDataWeightUnitEnum = typeof ParcelDataWeightUnitEnum[keyof typeof ParcelDataWeightUnitEnum];
export const ParcelDataDimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN'
} as const;

export type ParcelDataDimensionUnitEnum = typeof ParcelDataDimensionUnitEnum[keyof typeof ParcelDataDimensionUnitEnum];

/**
 * 
 * @export
 * @interface ParcelList
 */
export interface ParcelList {
    /**
     * 
     * @type {number}
     * @memberof ParcelList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Parcel>}
     * @memberof ParcelList
     */
    'results': Array<Parcel>;
}
/**
 * The payment details
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The payor type
     * @type {string}
     * @memberof Payment
     */
    'paid_by'?: PaymentPaidByEnum;
    /**
     * The payment amount currency
     * @type {string}
     * @memberof Payment
     */
    'currency'?: PaymentCurrencyEnum;
    /**
     * The payor account number
     * @type {string}
     * @memberof Payment
     */
    'account_number'?: string | null;
}

export const PaymentPaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party'
} as const;

export type PaymentPaidByEnum = typeof PaymentPaidByEnum[keyof typeof PaymentPaidByEnum];
export const PaymentCurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type PaymentCurrencyEnum = typeof PaymentCurrencyEnum[keyof typeof PaymentCurrencyEnum];

/**
 * 
 * @export
 * @interface Pickup
 */
export interface Pickup {
    /**
     * A unique pickup identifier
     * @type {string}
     * @memberof Pickup
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Pickup
     */
    'object_type'?: string;
    /**
     * The pickup carrier
     * @type {string}
     * @memberof Pickup
     */
    'carrier_name': string;
    /**
     * The pickup carrier configured name
     * @type {string}
     * @memberof Pickup
     */
    'carrier_id': string;
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof Pickup
     */
    'confirmation_number': string;
    /**
     * The pickup date
     * @type {string}
     * @memberof Pickup
     */
    'pickup_date'?: string | null;
    /**
     * 
     * @type {Charge}
     * @memberof Pickup
     */
    'pickup_charge'?: Charge;
    /**
     * The pickup expected ready time
     * @type {string}
     * @memberof Pickup
     */
    'ready_time'?: string | null;
    /**
     * The pickup expected closing or late time
     * @type {string}
     * @memberof Pickup
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Pickup
     */
    'address': Address;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof Pickup
     */
    'parcels': Array<Parcel>;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof Pickup
     */
    'instruction'?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof Pickup
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof Pickup
     */
    'options'?: object | null;
    /**
     * User metadata for the pickup
     * @type {object}
     * @memberof Pickup
     */
    'metadata'?: object;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Pickup
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface PickupCancelData
 */
export interface PickupCancelData {
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelData
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface PickupCancelRequest
 */
export interface PickupCancelRequest {
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'confirmation_number': string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupCancelRequest
     */
    'address'?: AddressData;
    /**
     *  The pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'pickup_date'?: string | null;
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface PickupData
 */
export interface PickupData {
    /**
     *  The expected pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupData
     */
    'pickup_date': string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupData
     */
    'address'?: AddressData;
    /**
     *  The ready time for pickup.  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupData
     */
    'ready_time': string;
    /**
     *  The closing or late time of the pickup  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupData
     */
    'closing_time': string;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupData
     */
    'instruction'?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupData
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupData
     */
    'options'?: object | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupData
     */
    'tracking_numbers': Array<string>;
    /**
     * User metadata for the pickup
     * @type {object}
     * @memberof PickupData
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface PickupList
 */
export interface PickupList {
    /**
     * 
     * @type {number}
     * @memberof PickupList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Pickup>}
     * @memberof PickupList
     */
    'results': Array<Pickup>;
}
/**
 * 
 * @export
 * @interface PickupRequest
 */
export interface PickupRequest {
    /**
     *  The expected pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupRequest
     */
    'pickup_date': string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupRequest
     */
    'address': AddressData;
    /**
     * The shipment parcels to pickup.
     * @type {Array<ParcelData>}
     * @memberof PickupRequest
     */
    'parcels': Array<ParcelData>;
    /**
     *  The ready time for pickup.  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupRequest
     */
    'ready_time': string;
    /**
     *  The closing or late time of the pickup  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupRequest
     */
    'closing_time': string;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupRequest
     */
    'instruction'?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupRequest
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupRequest
     */
    'options'?: object | null;
}
/**
 * 
 * @export
 * @interface PickupResponse
 */
export interface PickupResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof PickupResponse
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {Pickup}
     * @memberof PickupResponse
     */
    'pickup'?: Pickup;
}
/**
 * 
 * @export
 * @interface PickupUpdateData
 */
export interface PickupUpdateData {
    /**
     *  The expected pickup date  Date Format: YYYY-MM-DD 
     * @type {string}
     * @memberof PickupUpdateData
     */
    'pickup_date'?: string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupUpdateData
     */
    'address'?: AddressData;
    /**
     * The ready time for pickup.
     * @type {string}
     * @memberof PickupUpdateData
     */
    'ready_time'?: string | null;
    /**
     * The closing or late time of the pickup
     * @type {string}
     * @memberof PickupUpdateData
     */
    'closing_time'?: string | null;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupUpdateData
     */
    'instruction'?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupUpdateData
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupUpdateData
     */
    'options'?: object | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupUpdateData
     */
    'tracking_numbers'?: Array<string>;
    /**
     * User metadata for the pickup
     * @type {object}
     * @memberof PickupUpdateData
     */
    'metadata'?: object;
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateData
     */
    'confirmation_number': string;
}
/**
 * 
 * @export
 * @interface PickupUpdateRequest
 */
export interface PickupUpdateRequest {
    /**
     *  The expected pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'pickup_date': string;
    /**
     * 
     * @type {Address}
     * @memberof PickupUpdateRequest
     */
    'address': Address;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof PickupUpdateRequest
     */
    'parcels': Array<Parcel>;
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'confirmation_number': string;
    /**
     *  The ready time for pickup.  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'ready_time': string;
    /**
     *  The closing or late time of the pickup  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'closing_time': string;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'instruction'?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupUpdateRequest
     */
    'options'?: object | null;
}
/**
 * 
 * @export
 * @interface Ping200Response
 */
export interface Ping200Response {
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'VERSION'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'APP_NAME'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'APP_WEBSITE'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'AUDIT_LOGGING'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'ALLOW_SIGNUP'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'ALLOW_ADMIN_APPROVED_SIGNUP'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'ALLOW_MULTI_ACCOUNT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'MULTI_ORGANIZATIONS'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'ORDERS_MANAGEMENT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'APPS_MANAGEMENT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'DOCUMENTS_MANAGEMENT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'DATA_IMPORT_EXPORT'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'CUSTOM_CARRIER_DEFINITION'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ping200Response
     */
    'PERSIST_SDK_TRACING'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'ADMIN'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'OPENAPI'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'GRAPHQL'?: string;
}
/**
 * The list for shipment rates fetched previously
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Rate
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Rate
     */
    'object_type'?: string;
    /**
     * The rate\'s carrier
     * @type {string}
     * @memberof Rate
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof Rate
     */
    'carrier_id': string;
    /**
     * The rate monetary values currency code
     * @type {string}
     * @memberof Rate
     */
    'currency'?: string;
    /**
     * The carrier\'s rate (quote) service
     * @type {string}
     * @memberof Rate
     */
    'service'?: string | null;
    /**
     *  The rate\'s monetary amount of the total charge.<br/> This is the gross amount of the rate after adding the additional charges 
     * @type {number}
     * @memberof Rate
     */
    'total_charge'?: number;
    /**
     * The estimated delivery transit days
     * @type {number}
     * @memberof Rate
     */
    'transit_days'?: number | null;
    /**
     * list of the rate\'s additional charges
     * @type {Array<Charge>}
     * @memberof Rate
     */
    'extra_charges'?: Array<Charge>;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof Rate
     */
    'meta'?: object | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Rate
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface RateRequest
 */
export interface RateRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof RateRequest
     */
    'shipper': AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof RateRequest
     */
    'recipient': AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof RateRequest
     */
    'parcels': Array<ParcelData>;
    /**
     *  The requested carrier service for the shipment.<br/> Please consult the reference for specific carriers services.  Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof RateRequest
     */
    'services'?: Array<string> | null;
    /**
     *  <details> <summary>The options available for the shipment.</summary>  ``` {     \"currency\": \"USD\",     \"insurance\": 100.00,     \"cash_on_delivery\": 30.00,     \"shipment_date\": \"2020-01-01\",     \"dangerous_good\": true,     \"declared_value\": 150.00,     \"email_notification\": true,     \"email_notification_to\": \"shipper@mail.com\",     \"signature_confirmation\": true, } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof RateRequest
     */
    'options'?: object;
    /**
     * The shipment reference
     * @type {string}
     * @memberof RateRequest
     */
    'reference'?: string | null;
    /**
     *  The list of configured carriers you wish to get rates from. 
     * @type {Array<string>}
     * @memberof RateRequest
     */
    'carrier_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RateResponse
 */
export interface RateResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof RateResponse
     */
    'messages'?: Array<Message>;
    /**
     * The list of returned rates
     * @type {Array<Rate>}
     * @memberof RateResponse
     */
    'rates': Array<Rate>;
}
/**
 * The shipments associated with the order.
 * @export
 * @interface Shipment
 */
export interface Shipment {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Shipment
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Shipment
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof Shipment
     */
    'tracking_url'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Shipment
     */
    'shipper': Address;
    /**
     * 
     * @type {Address}
     * @memberof Shipment
     */
    'recipient': Address;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof Shipment
     */
    'parcels': Array<Parcel>;
    /**
     *  The carriers services requested for the shipment.  Please consult the reference for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof Shipment
     */
    'services'?: Array<string> | null;
    /**
     *  <details> <summary>The options available for the shipment.</summary>  ``` {     \"currency\": \"USD\",     \"insurance\": 100.00,     \"cash_on_delivery\": 30.00,     \"shipment_date\": \"2020-01-01\",     \"dangerous_good\": true,     \"declared_value\": 150.00,     \"email_notification\": true,     \"email_notification_to\": \"shipper@mail.com\",     \"signature_confirmation\": true, } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof Shipment
     */
    'options'?: object;
    /**
     * 
     * @type {Payment}
     * @memberof Shipment
     */
    'payment'?: Payment;
    /**
     * 
     * @type {Customs}
     * @memberof Shipment
     */
    'customs'?: Customs;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof Shipment
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     * @type {string}
     * @memberof Shipment
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof Shipment
     */
    'label_type'?: ShipmentLabelTypeEnum;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof Shipment
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof Shipment
     */
    'tracker_id'?: string | null;
    /**
     *  The shipment creation datetime  Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz` 
     * @type {string}
     * @memberof Shipment
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof Shipment
     */
    'metadata'?: object;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof Shipment
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     * @type {string}
     * @memberof Shipment
     */
    'status'?: ShipmentStatusEnum;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof Shipment
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof Shipment
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof Shipment
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof Shipment
     */
    'shipment_identifier'?: string | null;
    /**
     * 
     * @type {Rate}
     * @memberof Shipment
     */
    'selected_rate'?: Rate;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof Shipment
     */
    'meta'?: object | null;
    /**
     * The selected service
     * @type {string}
     * @memberof Shipment
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof Shipment
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Shipment
     */
    'test_mode': boolean;
    /**
     * The shipment label URL
     * @type {string}
     * @memberof Shipment
     */
    'label_url'?: string | null;
    /**
     * The shipment invoice URL
     * @type {string}
     * @memberof Shipment
     */
    'invoice_url'?: string | null;
}

export const ShipmentLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentLabelTypeEnum = typeof ShipmentLabelTypeEnum[keyof typeof ShipmentLabelTypeEnum];
export const ShipmentStatusEnum = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered'
} as const;

export type ShipmentStatusEnum = typeof ShipmentStatusEnum[keyof typeof ShipmentStatusEnum];

/**
 * 
 * @export
 * @interface ShipmentCancelRequest
 */
export interface ShipmentCancelRequest {
    /**
     * The shipment identifier returned during creation
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'shipment_identifier': string;
    /**
     * The selected shipment service
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'service'?: string | null;
    /**
     * Advanced carrier specific cancellation options
     * @type {object}
     * @memberof ShipmentCancelRequest
     */
    'options'?: object;
}
/**
 * 
 * @export
 * @interface ShipmentData
 */
export interface ShipmentData {
    /**
     * 
     * @type {AddressData}
     * @memberof ShipmentData
     */
    'shipper': AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof ShipmentData
     */
    'recipient': AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShipmentData
     */
    'parcels': Array<ParcelData>;
    /**
     *  <details> <summary>The options available for the shipment.</summary>  ``` {     \"currency\": \"USD\",     \"insurance\": 100.00,     \"cash_on_delivery\": 30.00,     \"shipment_date\": \"2020-01-01\",     \"dangerous_good\": true,     \"declared_value\": 150.00,     \"email_notification\": true,     \"email_notification_to\": \"shipper@mail.com\",     \"signature_confirmation\": true, } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof ShipmentData
     */
    'options'?: object;
    /**
     * 
     * @type {Payment}
     * @memberof ShipmentData
     */
    'payment'?: Payment;
    /**
     * 
     * @type {CustomsData}
     * @memberof ShipmentData
     */
    'customs'?: CustomsData;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentData
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentData
     */
    'label_type'?: ShipmentDataLabelTypeEnum;
    /**
     * **Specify a service to Buy a label in one call without rating.**
     * @type {string}
     * @memberof ShipmentData
     */
    'service'?: string;
    /**
     *  The requested carrier service for the shipment.  Please consult the reference for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    'services'?: Array<string> | null;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof ShipmentData
     */
    'metadata'?: object;
}

export const ShipmentDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentDataLabelTypeEnum = typeof ShipmentDataLabelTypeEnum[keyof typeof ShipmentDataLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShipmentList
 */
export interface ShipmentList {
    /**
     * 
     * @type {number}
     * @memberof ShipmentList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Shipment>}
     * @memberof ShipmentList
     */
    'results': Array<Shipment>;
}
/**
 * 
 * @export
 * @interface ShipmentPurchaseData
 */
export interface ShipmentPurchaseData {
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'selected_rate_id': string;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'label_type'?: ShipmentPurchaseDataLabelTypeEnum;
    /**
     * 
     * @type {Payment}
     * @memberof ShipmentPurchaseData
     */
    'payment'?: Payment;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof ShipmentPurchaseData
     */
    'metadata'?: object;
}

export const ShipmentPurchaseDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentPurchaseDataLabelTypeEnum = typeof ShipmentPurchaseDataLabelTypeEnum[keyof typeof ShipmentPurchaseDataLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShipmentRateData
 */
export interface ShipmentRateData {
    /**
     *  The requested carrier service for the shipment.  Please consult [the reference](#operation/references) for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    'services'?: Array<string> | null;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentRateData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof ShipmentRateData
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ShipmentUpdateData
 */
export interface ShipmentUpdateData {
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentUpdateData
     */
    'label_type'?: ShipmentUpdateDataLabelTypeEnum;
    /**
     * 
     * @type {Payment}
     * @memberof ShipmentUpdateData
     */
    'payment'?: Payment;
    /**
     *  <details> <summary>The options available for the shipment.</summary>  ``` {     \"currency\": \"USD\",     \"insurance\": 100.00,     \"cash_on_delivery\": 30.00,     \"shipment_date\": \"2020-01-01\",     \"dangerous_good\": true,     \"declared_value\": 150.00,     \"email_notification\": true,     \"email_notification_to\": \"shipper@mail.com\",     \"signature_confirmation\": true, } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof ShipmentUpdateData
     */
    'options'?: object | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentUpdateData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof ShipmentUpdateData
     */
    'metadata'?: object;
}

export const ShipmentUpdateDataLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShipmentUpdateDataLabelTypeEnum = typeof ShipmentUpdateDataLabelTypeEnum[keyof typeof ShipmentUpdateDataLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShippingRequest
 */
export interface ShippingRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    'shipper': AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    'recipient': AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShippingRequest
     */
    'parcels': Array<ParcelData>;
    /**
     *  <details> <summary>The options available for the shipment.</summary>  ``` {     \"currency\": \"USD\",     \"insurance\": 100.00,     \"cash_on_delivery\": 30.00,     \"shipment_date\": \"2020-01-01\",     \"dangerous_good\": true,     \"declared_value\": 150.00,     \"email_notification\": true,     \"email_notification_to\": \"shipper@mail.com\",     \"signature_confirmation\": true, } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof ShippingRequest
     */
    'options'?: object;
    /**
     * 
     * @type {Payment}
     * @memberof ShippingRequest
     */
    'payment'?: Payment;
    /**
     * 
     * @type {CustomsData}
     * @memberof ShippingRequest
     */
    'customs'?: CustomsData;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingRequest
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShippingRequest
     */
    'label_type'?: ShippingRequestLabelTypeEnum;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingRequest
     */
    'selected_rate_id': string;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingRequest
     */
    'rates': Array<Rate>;
}

export const ShippingRequestLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShippingRequestLabelTypeEnum = typeof ShippingRequestLabelTypeEnum[keyof typeof ShippingRequestLabelTypeEnum];

/**
 * 
 * @export
 * @interface ShippingResponse
 */
export interface ShippingResponse {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShippingResponse
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracking_url'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof ShippingResponse
     */
    'shipper': Address;
    /**
     * 
     * @type {Address}
     * @memberof ShippingResponse
     */
    'recipient': Address;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof ShippingResponse
     */
    'parcels': Array<Parcel>;
    /**
     *  The carriers services requested for the shipment.  Please consult the reference for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof ShippingResponse
     */
    'services'?: Array<string> | null;
    /**
     *  <details> <summary>The options available for the shipment.</summary>  ``` {     \"currency\": \"USD\",     \"insurance\": 100.00,     \"cash_on_delivery\": 30.00,     \"shipment_date\": \"2020-01-01\",     \"dangerous_good\": true,     \"declared_value\": 150.00,     \"email_notification\": true,     \"email_notification_to\": \"shipper@mail.com\",     \"signature_confirmation\": true, } ```  Please check the docs for carrier specific options. </details> 
     * @type {object}
     * @memberof ShippingResponse
     */
    'options'?: object;
    /**
     * 
     * @type {Payment}
     * @memberof ShippingResponse
     */
    'payment'?: Payment;
    /**
     * 
     * @type {Customs}
     * @memberof ShippingResponse
     */
    'customs'?: Customs;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingResponse
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingResponse
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShippingResponse
     */
    'label_type'?: ShippingResponseLabelTypeEnum;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof ShippingResponse
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracker_id'?: string | null;
    /**
     *  The shipment creation datetime  Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz` 
     * @type {string}
     * @memberof ShippingResponse
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     * @type {object}
     * @memberof ShippingResponse
     */
    'metadata'?: object;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof ShippingResponse
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     * @type {string}
     * @memberof ShippingResponse
     */
    'status'?: ShippingResponseStatusEnum;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof ShippingResponse
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'shipment_identifier'?: string | null;
    /**
     * 
     * @type {Rate}
     * @memberof ShippingResponse
     */
    'selected_rate'?: Rate;
    /**
     * 
     * @type {Documents}
     * @memberof ShippingResponse
     */
    'docs'?: Documents | null;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof ShippingResponse
     */
    'meta'?: object | null;
    /**
     * The selected service
     * @type {string}
     * @memberof ShippingResponse
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingResponse
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof ShippingResponse
     */
    'test_mode': boolean;
}

export const ShippingResponseLabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type ShippingResponseLabelTypeEnum = typeof ShippingResponseLabelTypeEnum[keyof typeof ShippingResponseLabelTypeEnum];
export const ShippingResponseStatusEnum = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered'
} as const;

export type ShippingResponseStatusEnum = typeof ShippingResponseStatusEnum[keyof typeof ShippingResponseStatusEnum];

/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access'?: string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TrackerList
 */
export interface TrackerList {
    /**
     * 
     * @type {number}
     * @memberof TrackerList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<TrackingStatus>}
     * @memberof TrackerList
     */
    'results': Array<TrackingStatus>;
}
/**
 * The tracking details events
 * @export
 * @interface TrackingEvent
 */
export interface TrackingEvent {
    /**
     * The tracking event\'s date
     * @type {string}
     * @memberof TrackingEvent
     */
    'date'?: string;
    /**
     * The tracking event\'s description
     * @type {string}
     * @memberof TrackingEvent
     */
    'description'?: string;
    /**
     * The tracking event\'s location
     * @type {string}
     * @memberof TrackingEvent
     */
    'location'?: string;
    /**
     * The tracking event\'s code
     * @type {string}
     * @memberof TrackingEvent
     */
    'code'?: string | null;
    /**
     * The tracking event\'s time
     * @type {string}
     * @memberof TrackingEvent
     */
    'time'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingResponse
 */
export interface TrackingResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingResponse
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {TrackingStatus}
     * @memberof TrackingResponse
     */
    'tracking'?: TrackingStatus;
}
/**
 * The tracking details retrieved
 * @export
 * @interface TrackingStatus
 */
export interface TrackingStatus {
    /**
     * A unique identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    'id'?: string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingStatus
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof TrackingStatus
     */
    'tracking_number': string;
    /**
     * The tracking details events
     * @type {Array<TrackingEvent>}
     * @memberof TrackingStatus
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     * @type {boolean}
     * @memberof TrackingStatus
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     * @type {boolean}
     * @memberof TrackingStatus
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     * @type {string}
     * @memberof TrackingStatus
     */
    'status'?: TrackingStatusStatusEnum;
    /**
     * The delivery estimated date
     * @type {string}
     * @memberof TrackingStatus
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof TrackingStatus
     */
    'meta'?: object | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof TrackingStatus
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     * @type {object}
     * @memberof TrackingStatus
     */
    'metadata'?: object;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingStatus
     */
    'messages'?: Array<Message>;
}

export const TrackingStatusStatusEnum = {
    Pending: 'pending',
    InTransit: 'in_transit',
    Incident: 'incident',
    Delivered: 'delivered',
    Unknown: 'unknown'
} as const;

export type TrackingStatusStatusEnum = typeof TrackingStatusStatusEnum[keyof typeof TrackingStatusStatusEnum];

/**
 * 
 * @export
 * @interface VerifiedTokenObtainPair
 */
export interface VerifiedTokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'access'?: string;
    /**
     *  The OTP (One Time Password) token received by the user from the configured Two Factor Authentication method. 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'otp_token': string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof Webhook
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof Webhook
     */
    'enabled_events': Array<WebhookEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof Webhook
     */
    'disabled'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Webhook
     */
    'object_type'?: string;
    /**
     * The datetime of the last event sent.
     * @type {string}
     * @memberof Webhook
     */
    'last_event_at'?: string | null;
    /**
     * Header signature secret
     * @type {string}
     * @memberof Webhook
     */
    'secret': string;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Webhook
     */
    'test_mode': boolean;
}

export const WebhookEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type WebhookEnabledEventsEnum = typeof WebhookEnabledEventsEnum[keyof typeof WebhookEnabledEventsEnum];

/**
 * 
 * @export
 * @interface WebhookData
 */
export interface WebhookData {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookData
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookData
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof WebhookData
     */
    'enabled_events': Array<WebhookDataEnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof WebhookData
     */
    'disabled'?: boolean | null;
}

export const WebhookDataEnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type WebhookDataEnabledEventsEnum = typeof WebhookDataEnabledEventsEnum[keyof typeof WebhookDataEnabledEventsEnum];

/**
 * 
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     * 
     * @type {number}
     * @memberof WebhookList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    'results': Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequest
     */
    'payload': object;
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (data: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('authenticate', 'data', data)
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Get a verified JWT token pair by submitting a Two-Factor authentication code. 
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken: async (data: VerifiedTokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getVerifiedToken', 'data', data)
            const localVarPath = `/api/token/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (data: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('refreshToken', 'data', data)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken: async (data: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('verifyToken', 'data', data)
            const localVarPath = `/api/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(data: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async data(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Data200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.data(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Get a verified JWT token pair by submitting a Two-Factor authentication code. 
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedToken(data: VerifiedTokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerifiedToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(data: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyToken(data: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(data: TokenObtainPair, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.authenticate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data(options?: any): AxiosPromise<Data200Response> {
            return localVarFp.data(options).then((request) => request(axios, basePath));
        },
        /**
         *  Get a verified JWT token pair by submitting a Two-Factor authentication code. 
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken(data: VerifiedTokenObtainPair, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.getVerifiedToken(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<Ping200Response> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(data: TokenRefresh, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.refreshToken(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken(data: TokenVerify, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.verifyToken(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticate operation in APIApi.
 * @export
 * @interface APIApiAuthenticateRequest
 */
export interface APIApiAuthenticateRequest {
    /**
     * 
     * @type {TokenObtainPair}
     * @memberof APIApiAuthenticate
     */
    readonly data: TokenObtainPair
}

/**
 * Request parameters for getVerifiedToken operation in APIApi.
 * @export
 * @interface APIApiGetVerifiedTokenRequest
 */
export interface APIApiGetVerifiedTokenRequest {
    /**
     * 
     * @type {VerifiedTokenObtainPair}
     * @memberof APIApiGetVerifiedToken
     */
    readonly data: VerifiedTokenObtainPair
}

/**
 * Request parameters for refreshToken operation in APIApi.
 * @export
 * @interface APIApiRefreshTokenRequest
 */
export interface APIApiRefreshTokenRequest {
    /**
     * 
     * @type {TokenRefresh}
     * @memberof APIApiRefreshToken
     */
    readonly data: TokenRefresh
}

/**
 * Request parameters for verifyToken operation in APIApi.
 * @export
 * @interface APIApiVerifyTokenRequest
 */
export interface APIApiVerifyTokenRequest {
    /**
     * 
     * @type {TokenVerify}
     * @memberof APIApiVerifyToken
     */
    readonly data: TokenVerify
}

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * Authenticate the user and return a token pair
     * @summary Obtain auth token pair
     * @param {APIApiAuthenticateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public authenticate(requestParameters: APIApiAuthenticateRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).authenticate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Data References
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public data(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).data(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Get a verified JWT token pair by submitting a Two-Factor authentication code. 
     * @summary Get verified JWT token
     * @param {APIApiGetVerifiedTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getVerifiedToken(requestParameters: APIApiGetVerifiedTokenRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).getVerifiedToken(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instance Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public ping(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate the user and return a token pair
     * @summary Refresh auth token
     * @param {APIApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public refreshToken(requestParameters: APIApiRefreshTokenRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).refreshToken(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify an existent authentication token
     * @summary Verify token
     * @param {APIApiVerifyTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public verifyToken(requestParameters: APIApiVerifyTokenRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).verifyToken(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: AddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: AddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: AddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: AddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: AddressData, options?: any): AxiosPromise<Address> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Address> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<AddressList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Address> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: AddressData, options?: any): AxiosPromise<Address> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in AddressesApi.
 * @export
 * @interface AddressesApiCreateRequest
 */
export interface AddressesApiCreateRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof AddressesApiCreate
     */
    readonly data: AddressData
}

/**
 * Request parameters for discard operation in AddressesApi.
 * @export
 * @interface AddressesApiDiscardRequest
 */
export interface AddressesApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for list operation in AddressesApi.
 * @export
 * @interface AddressesApiListRequest
 */
export interface AddressesApiListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof AddressesApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof AddressesApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in AddressesApi.
 * @export
 * @interface AddressesApiRetrieveRequest
 */
export interface AddressesApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in AddressesApi.
 * @export
 * @interface AddressesApiUpdateRequest
 */
export interface AddressesApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {AddressData}
     * @memberof AddressesApiUpdate
     */
    readonly data: AddressData
}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Create a new address.
     * @summary Create an address
     * @param {AddressesApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public create(requestParameters: AddressesApiCreateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).create(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard an address.
     * @summary Discard an address
     * @param {AddressesApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public discard(requestParameters: AddressesApiDiscardRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all addresses.
     * @summary List all addresses
     * @param {AddressesApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public list(requestParameters: AddressesApiListRequest = {}, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).list(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an address.
     * @summary Retrieve an address
     * @param {AddressesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public retrieve(requestParameters: AddressesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an address.
     * @summary Update an address
     * @param {AddressesApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public update(requestParameters: AddressesApiUpdateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all batch operations.
         * @summary List all batch operations
         * @param {string} [resourceType]  the batch resource type Values: &#x60;order&#x60;, &#x60;shipment&#x60;, &#x60;tracking&#x60;, &#x60;billing&#x60; 
         * @param {string} [status]  the batch operation status Values: &#x60;queued&#x60;, &#x60;running&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60; 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (resourceType?: string, status?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a batch operation.
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/batches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all batch operations.
         * @summary List all batch operations
         * @param {string} [resourceType]  the batch resource type Values: &#x60;order&#x60;, &#x60;shipment&#x60;, &#x60;tracking&#x60;, &#x60;billing&#x60; 
         * @param {string} [status]  the batch operation status Values: &#x60;queued&#x60;, &#x60;running&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60; 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(resourceType?: string, status?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(resourceType, status, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a batch operation.
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Retrieve all batch operations.
         * @summary List all batch operations
         * @param {string} [resourceType]  the batch resource type Values: &#x60;order&#x60;, &#x60;shipment&#x60;, &#x60;tracking&#x60;, &#x60;billing&#x60; 
         * @param {string} [status]  the batch operation status Values: &#x60;queued&#x60;, &#x60;running&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60; 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(resourceType?: string, status?: string, limit?: number, offset?: number, options?: any): AxiosPromise<BatchOperations> {
            return localVarFp.list(resourceType, status, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a batch operation.
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for list operation in BatchesApi.
 * @export
 * @interface BatchesApiListRequest
 */
export interface BatchesApiListRequest {
    /**
     *  the batch resource type Values: &#x60;order&#x60;, &#x60;shipment&#x60;, &#x60;tracking&#x60;, &#x60;billing&#x60; 
     * @type {string}
     * @memberof BatchesApiList
     */
    readonly resourceType?: string

    /**
     *  the batch operation status Values: &#x60;queued&#x60;, &#x60;running&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60; 
     * @type {string}
     * @memberof BatchesApiList
     */
    readonly status?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof BatchesApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof BatchesApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in BatchesApi.
 * @export
 * @interface BatchesApiRetrieveRequest
 */
export interface BatchesApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof BatchesApiRetrieve
     */
    readonly id: string
}

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Retrieve all batch operations.
     * @summary List all batch operations
     * @param {BatchesApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public list(requestParameters: BatchesApiListRequest = {}, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).list(requestParameters.resourceType, requestParameters.status, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a batch operation.
     * @summary Retrieve a batch operation
     * @param {BatchesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public retrieve(requestParameters: BatchesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CarriersApi - axios parameter creator
 * @export
 */
export const CarriersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getServices', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers/{carrier_name}/services`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
         * @param {boolean} [active] This flag indicates whether to return active carriers only
         * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', active?: boolean, systemOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['system_only'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarriersApi - functional programming interface
 * @export
 */
export const CarriersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarriersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(carrierName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
         * @param {boolean} [active] This flag indicates whether to return active carriers only
         * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', active?: boolean, systemOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, carrierName, active, systemOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarriersApi - factory interface
 * @export
 */
export const CarriersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarriersApiFp(configuration)
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getServices(carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
         * @param {boolean} [active] This flag indicates whether to return active carriers only
         * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', active?: boolean, systemOnly?: boolean, options?: any): AxiosPromise<CarrierList> {
            return localVarFp.list(limit, offset, carrierName, active, systemOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getServices operation in CarriersApi.
 * @export
 * @interface CarriersApiGetServicesRequest
 */
export interface CarriersApiGetServicesRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof CarriersApiGetServices
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'
}

/**
 * Request parameters for list operation in CarriersApi.
 * @export
 * @interface CarriersApiListRequest
 */
export interface CarriersApiListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CarriersApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CarriersApiList
     */
    readonly offset?: number

    /**
     * Indicates a carrier (type)
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof CarriersApiList
     */
    readonly carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * This flag indicates whether to return active carriers only
     * @type {boolean}
     * @memberof CarriersApiList
     */
    readonly active?: boolean

    /**
     * This flag indicates that only system carriers should be returned
     * @type {boolean}
     * @memberof CarriersApiList
     */
    readonly systemOnly?: boolean
}

/**
 * CarriersApi - object-oriented interface
 * @export
 * @class CarriersApi
 * @extends {BaseAPI}
 */
export class CarriersApi extends BaseAPI {
    /**
     * Retrieve a carrier\'s services
     * @summary Get carrier services
     * @param {CarriersApiGetServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public getServices(requestParameters: CarriersApiGetServicesRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).getServices(requestParameters.carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of configured carriers
     * @summary List all carriers
     * @param {CarriersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public list(requestParameters: CarriersApiListRequest = {}, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).list(requestParameters.limit, requestParameters.offset, requestParameters.carrierName, requestParameters.active, requestParameters.systemOnly, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomsApi - axios parameter creator
 * @export
 */
export const CustomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: CustomsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/customs_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customs_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: CustomsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomsApi - functional programming interface
 * @export
 */
export const CustomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: CustomsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: CustomsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomsApi - factory interface
 * @export
 */
export const CustomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomsApiFp(configuration)
    return {
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: CustomsData, options?: any): AxiosPromise<Customs> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Customs> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<CustomsList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Customs> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: CustomsData, options?: any): AxiosPromise<Customs> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in CustomsApi.
 * @export
 * @interface CustomsApiCreateRequest
 */
export interface CustomsApiCreateRequest {
    /**
     * 
     * @type {CustomsData}
     * @memberof CustomsApiCreate
     */
    readonly data: CustomsData
}

/**
 * Request parameters for discard operation in CustomsApi.
 * @export
 * @interface CustomsApiDiscardRequest
 */
export interface CustomsApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomsApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for list operation in CustomsApi.
 * @export
 * @interface CustomsApiListRequest
 */
export interface CustomsApiListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CustomsApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CustomsApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in CustomsApi.
 * @export
 * @interface CustomsApiRetrieveRequest
 */
export interface CustomsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in CustomsApi.
 * @export
 * @interface CustomsApiUpdateRequest
 */
export interface CustomsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {CustomsData}
     * @memberof CustomsApiUpdate
     */
    readonly data: CustomsData
}

/**
 * CustomsApi - object-oriented interface
 * @export
 * @class CustomsApi
 * @extends {BaseAPI}
 */
export class CustomsApi extends BaseAPI {
    /**
     * Create a new customs declaration.
     * @summary Create a customs info
     * @param {CustomsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public create(requestParameters: CustomsApiCreateRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).create(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a customs declaration.
     * @summary Discard a customs info
     * @param {CustomsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public discard(requestParameters: CustomsApiDiscardRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored customs declarations.
     * @summary List all customs info
     * @param {CustomsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public list(requestParameters: CustomsApiListRequest = {}, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).list(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve customs declaration.
     * @summary Retrieve a customs info
     * @param {CustomsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public retrieve(requestParameters: CustomsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing customs declaration.
     * @summary Update a customs info
     * @param {CustomsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public update(requestParameters: CustomsApiUpdateRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import csv, xls and xlsx data files for: - tracking data - orders data - shipments data - billing data (soon)  **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {string} [resourceType] The type of the resource to import
         * @param {string} [dataTemplate]  A data template slug to use for the import.  **When nothing is specified, the system default headers are expected.** 
         * @param {File} [dataFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile: async (resourceType?: string, dataTemplate?: string, dataFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (resourceType !== undefined) { 
                localVarFormParams.append('resource_type', resourceType as any);
            }
    
            if (dataTemplate !== undefined) { 
                localVarFormParams.append('data_template', dataTemplate as any);
            }
    
            if (dataFile !== undefined) { 
                localVarFormParams.append('data_file', dataFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Import csv, xls and xlsx data files for: - tracking data - orders data - shipments data - billing data (soon)  **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {string} [resourceType] The type of the resource to import
         * @param {string} [dataTemplate]  A data template slug to use for the import.  **When nothing is specified, the system default headers are expected.** 
         * @param {File} [dataFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFile(resourceType?: string, dataTemplate?: string, dataFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFile(resourceType, dataTemplate, dataFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Import csv, xls and xlsx data files for: - tracking data - orders data - shipments data - billing data (soon)  **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {string} [resourceType] The type of the resource to import
         * @param {string} [dataTemplate]  A data template slug to use for the import.  **When nothing is specified, the system default headers are expected.** 
         * @param {File} [dataFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile(resourceType?: string, dataTemplate?: string, dataFile?: File, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.importFile(resourceType, dataTemplate, dataFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for importFile operation in DataApi.
 * @export
 * @interface DataApiImportFileRequest
 */
export interface DataApiImportFileRequest {
    /**
     * The type of the resource to import
     * @type {string}
     * @memberof DataApiImportFile
     */
    readonly resourceType?: string

    /**
     *  A data template slug to use for the import.  **When nothing is specified, the system default headers are expected.** 
     * @type {string}
     * @memberof DataApiImportFile
     */
    readonly dataTemplate?: string

    /**
     * 
     * @type {File}
     * @memberof DataApiImportFile
     */
    readonly dataFile?: File
}

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Import csv, xls and xlsx data files for: - tracking data - orders data - shipments data - billing data (soon)  **This operation will return a batch operation that you can poll to follow the import progression.**
     * @summary Import data files
     * @param {DataApiImportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public importFile(requestParameters: DataApiImportFileRequest = {}, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).importFile(requestParameters.resourceType, requestParameters.dataTemplate, requestParameters.dataFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [dateAfter] 
         * @param {string} [dateBefore] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (dateAfter?: string, dateBefore?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dateAfter !== undefined) {
                localVarQueryParameter['date_after'] = dateAfter;
            }

            if (dateBefore !== undefined) {
                localVarQueryParameter['date_before'] = dateBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve an upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (data: DocumentUploadData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('upload', 'data', data)
            const localVarPath = `/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [dateAfter] 
         * @param {string} [dateBefore] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(dateAfter?: string, dateBefore?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecords>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(dateAfter, dateBefore, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve an upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(data: DocumentUploadData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {string} [dateAfter] 
         * @param {string} [dateBefore] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(dateAfter?: string, dateBefore?: string, limit?: number, offset?: number, options?: any): AxiosPromise<DocumentUploadRecords> {
            return localVarFp.list(dateAfter, dateBefore, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve an upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(data: DocumentUploadData, options?: any): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.upload(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for list operation in DocumentsApi.
 * @export
 * @interface DocumentsApiListRequest
 */
export interface DocumentsApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiList
     */
    readonly dateAfter?: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiList
     */
    readonly dateBefore?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DocumentsApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DocumentsApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in DocumentsApi.
 * @export
 * @interface DocumentsApiRetrieveRequest
 */
export interface DocumentsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for upload operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadRequest
 */
export interface DocumentsApiUploadRequest {
    /**
     * 
     * @type {DocumentUploadData}
     * @memberof DocumentsApiUpload
     */
    readonly data: DocumentUploadData
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Retrieve all shipping document upload records.
     * @summary List all upload records
     * @param {DocumentsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public list(requestParameters: DocumentsApiListRequest = {}, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).list(requestParameters.dateAfter, requestParameters.dateBefore, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipping document upload record.
     * @summary Retrieve an upload record
     * @param {DocumentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public retrieve(requestParameters: DocumentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a shipping document.
     * @summary Upload documents
     * @param {DocumentsApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public upload(requestParameters: DocumentsApiUploadRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).upload(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: OrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {string} [address] customer address line
         * @param {string} [id] id(s).
         * @param {string} [orderId] source order order_id(s).
         * @param {string} [source] order source(s).
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [status] order statuses.
         * @param {string} [optionKey] order option keys.
         * @param {string} [optionValue] order option value
         * @param {string} [metadataKey] order metadata keys.
         * @param {string} [metadataValue] order metadata value
         * @param {string} [keyword] order\&#39; keyword and indexes search
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (address?: string, id?: string, orderId?: string, source?: string, createdAfter?: string, createdBefore?: string, status?: string, optionKey?: string, optionValue?: string, metadataKey?: string, metadataValue?: string, keyword?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['order_id'] = orderId;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (optionKey !== undefined) {
                localVarQueryParameter['option_key'] = optionKey;
            }

            if (optionValue !== undefined) {
                localVarQueryParameter['option_value'] = optionValue;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: OrderUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: OrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {string} [address] customer address line
         * @param {string} [id] id(s).
         * @param {string} [orderId] source order order_id(s).
         * @param {string} [source] order source(s).
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [status] order statuses.
         * @param {string} [optionKey] order option keys.
         * @param {string} [optionValue] order option value
         * @param {string} [metadataKey] order metadata keys.
         * @param {string} [metadataValue] order metadata value
         * @param {string} [keyword] order\&#39; keyword and indexes search
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(address?: string, id?: string, orderId?: string, source?: string, createdAfter?: string, createdBefore?: string, status?: string, optionKey?: string, optionValue?: string, metadataKey?: string, metadataValue?: string, keyword?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(address, id, orderId, source, createdAfter, createdBefore, status, optionKey, optionValue, metadataKey, metadataValue, keyword, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: OrderUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, options?: any): AxiosPromise<Order> {
            return localVarFp.cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: OrderData, options?: any): AxiosPromise<Order> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {string} [address] customer address line
         * @param {string} [id] id(s).
         * @param {string} [orderId] source order order_id(s).
         * @param {string} [source] order source(s).
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [status] order statuses.
         * @param {string} [optionKey] order option keys.
         * @param {string} [optionValue] order option value
         * @param {string} [metadataKey] order metadata keys.
         * @param {string} [metadataValue] order metadata value
         * @param {string} [keyword] order\&#39; keyword and indexes search
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(address?: string, id?: string, orderId?: string, source?: string, createdAfter?: string, createdBefore?: string, status?: string, optionKey?: string, optionValue?: string, metadataKey?: string, metadataValue?: string, keyword?: string, limit?: number, offset?: number, options?: any): AxiosPromise<OrderList> {
            return localVarFp.list(address, id, orderId, source, createdAfter, createdBefore, status, optionKey, optionValue, metadataKey, metadataValue, keyword, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Order> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: OrderUpdateData, options?: any): AxiosPromise<Order> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in OrdersApi.
 * @export
 * @interface OrdersApiCancelRequest
 */
export interface OrdersApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for create operation in OrdersApi.
 * @export
 * @interface OrdersApiCreateRequest
 */
export interface OrdersApiCreateRequest {
    /**
     * 
     * @type {OrderData}
     * @memberof OrdersApiCreate
     */
    readonly data: OrderData
}

/**
 * Request parameters for list operation in OrdersApi.
 * @export
 * @interface OrdersApiListRequest
 */
export interface OrdersApiListRequest {
    /**
     * customer address line
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly address?: string

    /**
     * id(s).
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly id?: string

    /**
     * source order order_id(s).
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly orderId?: string

    /**
     * order source(s).
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly source?: string

    /**
     * DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly createdAfter?: string

    /**
     * DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly createdBefore?: string

    /**
     * order statuses.
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly status?: string

    /**
     * order option keys.
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly optionKey?: string

    /**
     * order option value
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly optionValue?: string

    /**
     * order metadata keys.
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly metadataKey?: string

    /**
     * order metadata value
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly metadataValue?: string

    /**
     * order\&#39; keyword and indexes search
     * @type {string}
     * @memberof OrdersApiList
     */
    readonly keyword?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof OrdersApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof OrdersApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in OrdersApi.
 * @export
 * @interface OrdersApiRetrieveRequest
 */
export interface OrdersApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in OrdersApi.
 * @export
 * @interface OrdersApiUpdateRequest
 */
export interface OrdersApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {OrderUpdateData}
     * @memberof OrdersApiUpdate
     */
    readonly data: OrderUpdateData
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Cancel an order.
     * @summary Cancel an order
     * @param {OrdersApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public cancel(requestParameters: OrdersApiCancelRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order object.
     * @summary Create an order
     * @param {OrdersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public create(requestParameters: OrdersApiCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).create(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders.
     * @summary List all orders
     * @param {OrdersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public list(requestParameters: OrdersApiListRequest = {}, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).list(requestParameters.address, requestParameters.id, requestParameters.orderId, requestParameters.source, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.status, requestParameters.optionKey, requestParameters.optionValue, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.keyword, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an order.
     * @summary Retrieve an order
     * @param {OrdersApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public retrieve(requestParameters: OrdersApiRetrieveRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
     * @summary Update an order
     * @param {OrdersApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public update(requestParameters: OrdersApiUpdateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParcelsApi - axios parameter creator
 * @export
 */
export const ParcelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: ParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: ParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParcelsApi - functional programming interface
 * @export
 */
export const ParcelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParcelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: ParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: ParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParcelsApi - factory interface
 * @export
 */
export const ParcelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParcelsApiFp(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: ParcelData, options?: any): AxiosPromise<Parcel> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Parcel> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<ParcelList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Parcel> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: ParcelData, options?: any): AxiosPromise<Parcel> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ParcelsApi.
 * @export
 * @interface ParcelsApiCreateRequest
 */
export interface ParcelsApiCreateRequest {
    /**
     * 
     * @type {ParcelData}
     * @memberof ParcelsApiCreate
     */
    readonly data: ParcelData
}

/**
 * Request parameters for discard operation in ParcelsApi.
 * @export
 * @interface ParcelsApiDiscardRequest
 */
export interface ParcelsApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for list operation in ParcelsApi.
 * @export
 * @interface ParcelsApiListRequest
 */
export interface ParcelsApiListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ParcelsApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ParcelsApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in ParcelsApi.
 * @export
 * @interface ParcelsApiRetrieveRequest
 */
export interface ParcelsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ParcelsApi.
 * @export
 * @interface ParcelsApiUpdateRequest
 */
export interface ParcelsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {ParcelData}
     * @memberof ParcelsApiUpdate
     */
    readonly data: ParcelData
}

/**
 * ParcelsApi - object-oriented interface
 * @export
 * @class ParcelsApi
 * @extends {BaseAPI}
 */
export class ParcelsApi extends BaseAPI {
    /**
     * Create a new parcel.
     * @summary Create a parcel
     * @param {ParcelsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public create(requestParameters: ParcelsApiCreateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).create(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a parcel.
     * @summary Remove a parcel
     * @param {ParcelsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public discard(requestParameters: ParcelsApiDiscardRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored parcels.
     * @summary List all parcels
     * @param {ParcelsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public list(requestParameters: ParcelsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).list(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a parcel.
     * @summary Retrieve a parcel
     * @param {ParcelsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public retrieve(requestParameters: ParcelsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing parcel\'s details.
     * @summary Update a parcel
     * @param {ParcelsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public update(requestParameters: ParcelsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PickupsApi - axios parameter creator
 * @export
 */
export const PickupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, data: PickupCancelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('cancel', 'data', data)
            const localVarPath = `/v1/pickups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule: async (carrierName: string, data: PickupData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedule', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('schedule', 'data', data)
            const localVarPath = `/v1/pickups/{carrier_name}/schedule`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: PickupUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PickupsApi - functional programming interface
 * @export
 */
export const PickupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PickupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, data: PickupCancelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedule(carrierName: string, data: PickupData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedule(carrierName, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: PickupUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PickupsApi - factory interface
 * @export
 */
export const PickupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PickupsApiFp(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, data: PickupCancelData, options?: any): AxiosPromise<Pickup> {
            return localVarFp.cancel(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<PickupList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Pickup> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule(carrierName: string, data: PickupData, options?: any): AxiosPromise<Pickup> {
            return localVarFp.schedule(carrierName, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: PickupUpdateData, options?: any): AxiosPromise<Pickup> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in PickupsApi.
 * @export
 * @interface PickupsApiCancelRequest
 */
export interface PickupsApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiCancel
     */
    readonly id: string

    /**
     * 
     * @type {PickupCancelData}
     * @memberof PickupsApiCancel
     */
    readonly data: PickupCancelData
}

/**
 * Request parameters for list operation in PickupsApi.
 * @export
 * @interface PickupsApiListRequest
 */
export interface PickupsApiListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof PickupsApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof PickupsApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for retrieve operation in PickupsApi.
 * @export
 * @interface PickupsApiRetrieveRequest
 */
export interface PickupsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for schedule operation in PickupsApi.
 * @export
 * @interface PickupsApiScheduleRequest
 */
export interface PickupsApiScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiSchedule
     */
    readonly carrierName: string

    /**
     * 
     * @type {PickupData}
     * @memberof PickupsApiSchedule
     */
    readonly data: PickupData
}

/**
 * Request parameters for update operation in PickupsApi.
 * @export
 * @interface PickupsApiUpdateRequest
 */
export interface PickupsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PickupUpdateData}
     * @memberof PickupsApiUpdate
     */
    readonly data: PickupUpdateData
}

/**
 * PickupsApi - object-oriented interface
 * @export
 * @class PickupsApi
 * @extends {BaseAPI}
 */
export class PickupsApi extends BaseAPI {
    /**
     * Cancel a pickup of one or more shipments.
     * @summary Cancel a pickup
     * @param {PickupsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public cancel(requestParameters: PickupsApiCancelRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).cancel(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all scheduled pickups.
     * @summary List shipment pickups
     * @param {PickupsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public list(requestParameters: PickupsApiListRequest = {}, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).list(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a scheduled pickup.
     * @summary Retrieve a pickup
     * @param {PickupsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public retrieve(requestParameters: PickupsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a pickup for one or many shipments with labels already purchased.
     * @summary Schedule a pickup
     * @param {PickupsApiScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public schedule(requestParameters: PickupsApiScheduleRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).schedule(requestParameters.carrierName, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a pickup for one or many shipments with labels already purchased.
     * @summary Update a pickup
     * @param {PickupsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public update(requestParameters: PickupsApiUpdateRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel: async (data: ShippingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('buyLabel', 'data', data)
            const localVarPath = `/v1/proxy/shipping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupCancelRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('cancelPickup', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('cancelPickup', 'data', data)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates: async (data: RateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('fetchRates', 'data', data)
            const localVarPath = `/v1/proxy/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedulePickup', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('schedulePickup', 'data', data)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {string} trackingNumber 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} [hub] A carrier_name of a hub connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackShipment: async (trackingNumber: string, carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('trackShipment', 'trackingNumber', trackingNumber)
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('trackShipment', 'carrierName', carrierName)
            const localVarPath = `/v1/proxy/tracking/{carrier_name}/{tracking_number}`
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)))
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupUpdateRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('updatePickup', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updatePickup', 'data', data)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/update`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {ShipmentCancelRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: ShipmentCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('voidLabel', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('voidLabel', 'data', data)
            const localVarPath = `/v1/proxy/shipping/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buyLabel(data: ShippingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buyLabel(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupCancelRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPickup(carrierName, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRates(data: RateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRates(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePickup(carrierName, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {string} trackingNumber 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} [hub] A carrier_name of a hub connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackShipment(trackingNumber: string, carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackShipment(trackingNumber, carrierName, hub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupUpdateRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePickup(carrierName, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {ShipmentCancelRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidLabel(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: ShipmentCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidLabel(carrierName, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel(data: ShippingRequest, options?: any): AxiosPromise<ShippingResponse> {
            return localVarFp.buyLabel(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupCancelRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupCancelRequest, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.cancelPickup(carrierName, data, options).then((request) => request(axios, basePath));
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates(data: RateRequest, options?: any): AxiosPromise<RateResponse> {
            return localVarFp.fetchRates(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupRequest, options?: any): AxiosPromise<PickupResponse> {
            return localVarFp.schedulePickup(carrierName, data, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {string} trackingNumber 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} [hub] A carrier_name of a hub connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackShipment(trackingNumber: string, carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', hub?: string, options?: any): AxiosPromise<TrackingResponse> {
            return localVarFp.trackShipment(trackingNumber, carrierName, hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupUpdateRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: PickupUpdateRequest, options?: any): AxiosPromise<PickupResponse> {
            return localVarFp.updatePickup(carrierName, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {ShipmentCancelRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', data: ShipmentCancelRequest, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.voidLabel(carrierName, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for buyLabel operation in ProxyApi.
 * @export
 * @interface ProxyApiBuyLabelRequest
 */
export interface ProxyApiBuyLabelRequest {
    /**
     * 
     * @type {ShippingRequest}
     * @memberof ProxyApiBuyLabel
     */
    readonly data: ShippingRequest
}

/**
 * Request parameters for cancelPickup operation in ProxyApi.
 * @export
 * @interface ProxyApiCancelPickupRequest
 */
export interface ProxyApiCancelPickupRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiCancelPickup
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {PickupCancelRequest}
     * @memberof ProxyApiCancelPickup
     */
    readonly data: PickupCancelRequest
}

/**
 * Request parameters for fetchRates operation in ProxyApi.
 * @export
 * @interface ProxyApiFetchRatesRequest
 */
export interface ProxyApiFetchRatesRequest {
    /**
     * 
     * @type {RateRequest}
     * @memberof ProxyApiFetchRates
     */
    readonly data: RateRequest
}

/**
 * Request parameters for schedulePickup operation in ProxyApi.
 * @export
 * @interface ProxyApiSchedulePickupRequest
 */
export interface ProxyApiSchedulePickupRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiSchedulePickup
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {PickupRequest}
     * @memberof ProxyApiSchedulePickup
     */
    readonly data: PickupRequest
}

/**
 * Request parameters for trackShipment operation in ProxyApi.
 * @export
 * @interface ProxyApiTrackShipmentRequest
 */
export interface ProxyApiTrackShipmentRequest {
    /**
     * 
     * @type {string}
     * @memberof ProxyApiTrackShipment
     */
    readonly trackingNumber: string

    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiTrackShipment
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * A carrier_name of a hub connector
     * @type {string}
     * @memberof ProxyApiTrackShipment
     */
    readonly hub?: string
}

/**
 * Request parameters for updatePickup operation in ProxyApi.
 * @export
 * @interface ProxyApiUpdatePickupRequest
 */
export interface ProxyApiUpdatePickupRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiUpdatePickup
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {PickupUpdateRequest}
     * @memberof ProxyApiUpdatePickup
     */
    readonly data: PickupUpdateRequest
}

/**
 * Request parameters for voidLabel operation in ProxyApi.
 * @export
 * @interface ProxyApiVoidLabelRequest
 */
export interface ProxyApiVoidLabelRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiVoidLabel
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {ShipmentCancelRequest}
     * @memberof ProxyApiVoidLabel
     */
    readonly data: ShipmentCancelRequest
}

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * @summary Buy a shipment label
     * @param {ProxyApiBuyLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public buyLabel(requestParameters: ProxyApiBuyLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).buyLabel(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a pickup previously scheduled
     * @summary Cancel a pickup
     * @param {ProxyApiCancelPickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public cancelPickup(requestParameters: ProxyApiCancelPickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).cancelPickup(requestParameters.carrierName, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * @summary Fetch shipment rates
     * @param {ProxyApiFetchRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public fetchRates(requestParameters: ProxyApiFetchRatesRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).fetchRates(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule one or many parcels pickup
     * @summary Schedule a pickup
     * @param {ProxyApiSchedulePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public schedulePickup(requestParameters: ProxyApiSchedulePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).schedulePickup(requestParameters.carrierName, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Track a shipment
     * @param {ProxyApiTrackShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public trackShipment(requestParameters: ProxyApiTrackShipmentRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).trackShipment(requestParameters.trackingNumber, requestParameters.carrierName, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a scheduled pickup
     * @summary Update a pickup
     * @param {ProxyApiUpdatePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public updatePickup(requestParameters: ProxyApiUpdatePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).updatePickup(requestParameters.carrierName, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a shipment and the label previously created
     * @summary Void a shipment label
     * @param {ProxyApiVoidLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public voidLabel(requestParameters: ProxyApiVoidLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).voidLabel(requestParameters.carrierName, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
export const ShipmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: ShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] shipment recipient address line
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [carrierName]  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
         * @param {string} [reference] a shipment reference
         * @param {string} [service] preferred carrier services.
         * @param {string} [status]  shipment status Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60; 
         * @param {string} [optionKey] shipment option keys.
         * @param {string} [optionValue] shipment option value
         * @param {string} [metadataKey] shipment metadata keys.
         * @param {string} [metadataValue] shipment metadata value
         * @param {string} [trackingNumber] 
         * @param {string} [keyword] shipment\&#39; keyword and indexes search
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (address?: string, createdAfter?: string, createdBefore?: string, carrierName?: string, reference?: string, service?: string, status?: string, optionKey?: string, optionValue?: string, metadataKey?: string, metadataValue?: string, trackingNumber?: string, keyword?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (optionKey !== undefined) {
                localVarQueryParameter['option_key'] = optionKey;
            }

            if (optionValue !== undefined) {
                localVarQueryParameter['option_value'] = optionValue;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (id: string, data: ShipmentPurchaseData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchase', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('purchase', 'data', data)
            const localVarPath = `/v1/shipments/{id}/purchase`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates: async (id: string, data: ShipmentRateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rates', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('rates', 'data', data)
            const localVarPath = `/v1/shipments/{id}/rates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: ShipmentUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipmentsApi - functional programming interface
 * @export
 */
export const ShipmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShipmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: ShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] shipment recipient address line
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [carrierName]  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
         * @param {string} [reference] a shipment reference
         * @param {string} [service] preferred carrier services.
         * @param {string} [status]  shipment status Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60; 
         * @param {string} [optionKey] shipment option keys.
         * @param {string} [optionValue] shipment option value
         * @param {string} [metadataKey] shipment metadata keys.
         * @param {string} [metadataValue] shipment metadata value
         * @param {string} [trackingNumber] 
         * @param {string} [keyword] shipment\&#39; keyword and indexes search
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(address?: string, createdAfter?: string, createdBefore?: string, carrierName?: string, reference?: string, service?: string, status?: string, optionKey?: string, optionValue?: string, metadataKey?: string, metadataValue?: string, trackingNumber?: string, keyword?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(address, createdAfter, createdBefore, carrierName, reference, service, status, optionKey, optionValue, metadataKey, metadataValue, trackingNumber, keyword, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(id: string, data: ShipmentPurchaseData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rates(id: string, data: ShipmentRateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rates(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: ShipmentUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShipmentsApi - factory interface
 * @export
 */
export const ShipmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShipmentsApiFp(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, options?: any): AxiosPromise<Shipment> {
            return localVarFp.cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: ShipmentData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] shipment recipient address line
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [carrierName]  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
         * @param {string} [reference] a shipment reference
         * @param {string} [service] preferred carrier services.
         * @param {string} [status]  shipment status Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60; 
         * @param {string} [optionKey] shipment option keys.
         * @param {string} [optionValue] shipment option value
         * @param {string} [metadataKey] shipment metadata keys.
         * @param {string} [metadataValue] shipment metadata value
         * @param {string} [trackingNumber] 
         * @param {string} [keyword] shipment\&#39; keyword and indexes search
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(address?: string, createdAfter?: string, createdBefore?: string, carrierName?: string, reference?: string, service?: string, status?: string, optionKey?: string, optionValue?: string, metadataKey?: string, metadataValue?: string, trackingNumber?: string, keyword?: string, limit?: number, offset?: number, options?: any): AxiosPromise<ShipmentList> {
            return localVarFp.list(address, createdAfter, createdBefore, carrierName, reference, service, status, optionKey, optionValue, metadataKey, metadataValue, trackingNumber, keyword, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(id: string, data: ShipmentPurchaseData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.purchase(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates(id: string, data: ShipmentRateData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.rates(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Shipment> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: ShipmentUpdateData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiCancelRequest
 */
export interface ShipmentsApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for create operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiCreateRequest
 */
export interface ShipmentsApiCreateRequest {
    /**
     * 
     * @type {ShipmentData}
     * @memberof ShipmentsApiCreate
     */
    readonly data: ShipmentData
}

/**
 * Request parameters for list operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiListRequest
 */
export interface ShipmentsApiListRequest {
    /**
     * shipment recipient address line
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly address?: string

    /**
     * DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly createdAfter?: string

    /**
     * DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly createdBefore?: string

    /**
     *  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly carrierName?: string

    /**
     * a shipment reference
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly reference?: string

    /**
     * preferred carrier services.
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly service?: string

    /**
     *  shipment status Values: &#x60;draft&#x60;, &#x60;purchased&#x60;, &#x60;cancelled&#x60;, &#x60;shipped&#x60;, &#x60;in_transit&#x60;, &#x60;delivered&#x60; 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly status?: string

    /**
     * shipment option keys.
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly optionKey?: string

    /**
     * shipment option value
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly optionValue?: string

    /**
     * shipment metadata keys.
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metadataKey?: string

    /**
     * shipment metadata value
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metadataValue?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly trackingNumber?: string

    /**
     * shipment\&#39; keyword and indexes search
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly keyword?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ShipmentsApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ShipmentsApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for purchase operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiPurchaseRequest
 */
export interface ShipmentsApiPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiPurchase
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentPurchaseData}
     * @memberof ShipmentsApiPurchase
     */
    readonly data: ShipmentPurchaseData
}

/**
 * Request parameters for rates operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiRatesRequest
 */
export interface ShipmentsApiRatesRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiRates
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentRateData}
     * @memberof ShipmentsApiRates
     */
    readonly data: ShipmentRateData
}

/**
 * Request parameters for retrieve operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiRetrieveRequest
 */
export interface ShipmentsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiUpdateRequest
 */
export interface ShipmentsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentUpdateData}
     * @memberof ShipmentsApiUpdate
     */
    readonly data: ShipmentUpdateData
}

/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Void a shipment with the associated label.
     * @summary Cancel a shipment
     * @param {ShipmentsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public cancel(requestParameters: ShipmentsApiCancelRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipment instance.
     * @summary Create a shipment
     * @param {ShipmentsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public create(requestParameters: ShipmentsApiCreateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).create(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipments.
     * @summary List all shipments
     * @param {ShipmentsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public list(requestParameters: ShipmentsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).list(requestParameters.address, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.carrierName, requestParameters.reference, requestParameters.service, requestParameters.status, requestParameters.optionKey, requestParameters.optionValue, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.trackingNumber, requestParameters.keyword, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select your preferred rates to buy a shipment label.
     * @summary Buy a shipment label
     * @param {ShipmentsApiPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public purchase(requestParameters: ShipmentsApiPurchaseRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).purchase(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh the list of the shipment rates
     * @summary Fetch new shipment rates
     * @param {ShipmentsApiRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public rates(requestParameters: ShipmentsApiRatesRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).rates(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment.
     * @summary Retrieve a shipment
     * @param {ShipmentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public retrieve(requestParameters: ShipmentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
     * @summary Update a shipment
     * @param {ShipmentsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public update(requestParameters: ShipmentsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackersApi - axios parameter creator
 * @export
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a shipment tracker
         * @param {string} trackingNumber 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} [hub] A carrier_name of a hub connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (trackingNumber: string, carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('create', 'trackingNumber', trackingNumber)
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('create', 'carrierName', carrierName)
            const localVarPath = `/v1/trackers/{carrier_name}/{tracking_number}`
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)))
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all shipment trackers
         * @param {string} [trackingNumber] a tracking number
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [carrierName]  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
         * @param {string} [status]  tracker status Values: &#x60;pending&#x60;, &#x60;in_transit&#x60;, &#x60;incident&#x60;, &#x60;delivered&#x60;, &#x60;unknown&#x60; 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (trackingNumber?: string, createdAfter?: string, createdBefore?: string, carrierName?: string, status?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a shipment tracker.
         * @summary Discard a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('remove', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment tracker
         * @summary Retrieves a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieves: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('retrieves', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 * @export
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a shipment tracker
         * @param {string} trackingNumber 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} [hub] A carrier_name of a hub connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(trackingNumber: string, carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(trackingNumber, carrierName, hub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all shipment trackers
         * @param {string} [trackingNumber] a tracking number
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [carrierName]  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
         * @param {string} [status]  tracker status Values: &#x60;pending&#x60;, &#x60;in_transit&#x60;, &#x60;incident&#x60;, &#x60;delivered&#x60;, &#x60;unknown&#x60; 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(trackingNumber?: string, createdAfter?: string, createdBefore?: string, carrierName?: string, status?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(trackingNumber, createdAfter, createdBefore, carrierName, status, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a shipment tracker.
         * @summary Discard a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(idOrTrackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipment tracker
         * @summary Retrieves a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieves(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieves(idOrTrackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackersApi - factory interface
 * @export
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a shipment tracker
         * @param {string} trackingNumber 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} [hub] A carrier_name of a hub connector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(trackingNumber: string, carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', hub?: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.create(trackingNumber, carrierName, hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all shipment trackers
         * @param {string} [trackingNumber] a tracking number
         * @param {string} [createdAfter] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [createdBefore] DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
         * @param {string} [carrierName]  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
         * @param {string} [status]  tracker status Values: &#x60;pending&#x60;, &#x60;in_transit&#x60;, &#x60;incident&#x60;, &#x60;delivered&#x60;, &#x60;unknown&#x60; 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(trackingNumber?: string, createdAfter?: string, createdBefore?: string, carrierName?: string, status?: string, limit?: number, offset?: number, options?: any): AxiosPromise<TrackerList> {
            return localVarFp.list(trackingNumber, createdAfter, createdBefore, carrierName, status, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a shipment tracker.
         * @summary Discard a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(idOrTrackingNumber: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.remove(idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment tracker
         * @summary Retrieves a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieves(idOrTrackingNumber: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.retrieves(idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in TrackersApi.
 * @export
 * @interface TrackersApiCreateRequest
 */
export interface TrackersApiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly trackingNumber: string

    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof TrackersApiCreate
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * A carrier_name of a hub connector
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly hub?: string
}

/**
 * Request parameters for list operation in TrackersApi.
 * @export
 * @interface TrackersApiListRequest
 */
export interface TrackersApiListRequest {
    /**
     * a tracking number
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly trackingNumber?: string

    /**
     * DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly createdAfter?: string

    /**
     * DateTime in format &#x60;YYYY-MM-DD H:M:S.fz&#x60;
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly createdBefore?: string

    /**
     *  carrier_name used to fulfill the shipment Values: &#x60;amazon_mws&#x60;, &#x60;aramex&#x60;, &#x60;australiapost&#x60;, &#x60;canadapost&#x60;, &#x60;canpar&#x60;, &#x60;chronopost&#x60;, &#x60;dhl_express&#x60;, &#x60;dhl_poland&#x60;, &#x60;dhl_universal&#x60;, &#x60;dicom&#x60;, &#x60;dpdhl&#x60;, &#x60;easypost&#x60;, &#x60;eshipper&#x60;, &#x60;fedex&#x60;, &#x60;freightcom&#x60;, &#x60;generic&#x60;, &#x60;purolator&#x60;, &#x60;royalmail&#x60;, &#x60;sendle&#x60;, &#x60;sf_express&#x60;, &#x60;tnt&#x60;, &#x60;ups&#x60;, &#x60;ups_freight&#x60;, &#x60;usps&#x60;, &#x60;usps_international&#x60;, &#x60;yanwen&#x60;, &#x60;yunexpress&#x60; 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly carrierName?: string

    /**
     *  tracker status Values: &#x60;pending&#x60;, &#x60;in_transit&#x60;, &#x60;incident&#x60;, &#x60;delivered&#x60;, &#x60;unknown&#x60; 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly status?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof TrackersApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof TrackersApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for remove operation in TrackersApi.
 * @export
 * @interface TrackersApiRemoveRequest
 */
export interface TrackersApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiRemove
     */
    readonly idOrTrackingNumber: string
}

/**
 * Request parameters for retrieves operation in TrackersApi.
 * @export
 * @interface TrackersApiRetrievesRequest
 */
export interface TrackersApiRetrievesRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiRetrieves
     */
    readonly idOrTrackingNumber: string
}

/**
 * TrackersApi - object-oriented interface
 * @export
 * @class TrackersApi
 * @extends {BaseAPI}
 */
export class TrackersApi extends BaseAPI {
    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Create a shipment tracker
     * @param {TrackersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public create(requestParameters: TrackersApiCreateRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).create(requestParameters.trackingNumber, requestParameters.carrierName, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipment trackers.
     * @summary List all shipment trackers
     * @param {TrackersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public list(requestParameters: TrackersApiListRequest = {}, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).list(requestParameters.trackingNumber, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.carrierName, requestParameters.status, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a shipment tracker.
     * @summary Discard a shipment tracker
     * @param {TrackersApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public remove(requestParameters: TrackersApiRemoveRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).remove(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment tracker
     * @summary Retrieves a shipment tracker
     * @param {TrackersApiRetrievesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public retrieves(requestParameters: TrackersApiRetrievesRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).retrieves(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: WebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (id: string, data: WebhookTestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('test', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('test', 'data', data)
            const localVarPath = `/v1/webhooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: WebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: WebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(id: string, data: WebhookTestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: WebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: WebhookData, options?: any): AxiosPromise<Webhook> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<WebhookList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.remove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(id: string, data: WebhookTestRequest, options?: any): AxiosPromise<Operation> {
            return localVarFp.test(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: WebhookData, options?: any): AxiosPromise<Webhook> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in WebhooksApi.
 * @export
 * @interface WebhooksApiCreateRequest
 */
export interface WebhooksApiCreateRequest {
    /**
     * 
     * @type {WebhookData}
     * @memberof WebhooksApiCreate
     */
    readonly data: WebhookData
}

/**
 * Request parameters for list operation in WebhooksApi.
 * @export
 * @interface WebhooksApiListRequest
 */
export interface WebhooksApiListRequest {
    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof WebhooksApiList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof WebhooksApiList
     */
    readonly offset?: number
}

/**
 * Request parameters for remove operation in WebhooksApi.
 * @export
 * @interface WebhooksApiRemoveRequest
 */
export interface WebhooksApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiRemove
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in WebhooksApi.
 * @export
 * @interface WebhooksApiRetrieveRequest
 */
export interface WebhooksApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for test operation in WebhooksApi.
 * @export
 * @interface WebhooksApiTestRequest
 */
export interface WebhooksApiTestRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiTest
     */
    readonly id: string

    /**
     * 
     * @type {WebhookTestRequest}
     * @memberof WebhooksApiTest
     */
    readonly data: WebhookTestRequest
}

/**
 * Request parameters for update operation in WebhooksApi.
 * @export
 * @interface WebhooksApiUpdateRequest
 */
export interface WebhooksApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {WebhookData}
     * @memberof WebhooksApiUpdate
     */
    readonly data: WebhookData
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook.
     * @summary Create a webhook
     * @param {WebhooksApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public create(requestParameters: WebhooksApiCreateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).create(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all webhooks.
     * @summary List all webhooks
     * @param {WebhooksApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public list(requestParameters: WebhooksApiListRequest = {}, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).list(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a webhook.
     * @summary Remove a webhook
     * @param {WebhooksApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public remove(requestParameters: WebhooksApiRemoveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).remove(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a webhook.
     * @summary Retrieve a webhook
     * @param {WebhooksApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public retrieve(requestParameters: WebhooksApiRetrieveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * test a webhook.
     * @summary Test a webhook
     * @param {WebhooksApiTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public test(requestParameters: WebhooksApiTestRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).test(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a webhook.
     * @summary Update a webhook
     * @param {WebhooksApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public update(requestParameters: WebhooksApiUpdateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).update(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


