/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2022.8.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * The error or warning message
     * @type {string}
     * @memberof APIError
     */
    'message'?: string;
    /**
     * The message code
     * @type {string}
     * @memberof APIError
     */
    'code'?: string;
    /**
     * any additional details
     * @type {{ [key: string]: any; }}
     * @memberof APIError
     */
    'details'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Address
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof Address
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof Address
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof Address
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof Address
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof Address
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof Address
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof Address
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof Address
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof Address
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof Address
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof Address
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof Address
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Address
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof Address
     */
    'validation'?: AddressValidation | null;
}
/**
 * 
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof AddressData
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof AddressData
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof AddressData
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof AddressData
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof AddressData
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof AddressData
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof AddressData
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof AddressData
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof AddressData
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof AddressData
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof AddressData
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof AddressData
     */
    'validate_location'?: boolean | null;
}
/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * 
     * @type {number}
     * @memberof AddressList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Address>}
     * @memberof AddressList
     */
    'results': Array<Address>;
}
/**
 * Specify address validation result
 * @export
 * @interface AddressValidation
 */
export interface AddressValidation {
    /**
     * True if the address is valid
     * @type {boolean}
     * @memberof AddressValidation
     */
    'success': boolean;
    /**
     * validation service details
     * @type {{ [key: string]: any; }}
     * @memberof AddressValidation
     */
    'meta'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface BatchObject
 */
export interface BatchObject {
    /**
     * A unique identifier
     * @type {string}
     * @memberof BatchObject
     */
    'id'?: string;
    /**
     * The batch operation resource status
     * @type {BatchOperationStatus}
     * @memberof BatchObject
     */
    'status': BatchOperationStatus;
    /**
     * Resource processing errors
     * @type {{ [key: string]: any; }}
     * @memberof BatchObject
     */
    'errors'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface BatchOperation
 */
export interface BatchOperation {
    /**
     * A unique identifier
     * @type {string}
     * @memberof BatchOperation
     */
    'id'?: string;
    /**
     * 
     * @type {BatchOperationStatus}
     * @memberof BatchOperation
     */
    'status': BatchOperationStatus;
    /**
     * 
     * @type {ResourceTypeEnum}
     * @memberof BatchOperation
     */
    'resource_type': ResourceTypeEnum;
    /**
     * 
     * @type {Array<BatchObject>}
     * @memberof BatchOperation
     */
    'resources': Array<BatchObject>;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BatchOperation
     */
    'updated_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof BatchOperation
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BatchOperationStatus = {
    Queued: 'queued',
    Running: 'running',
    Failed: 'failed',
    Completed: 'completed',
    CompletedWithErrors: 'completed_with_errors'
} as const;

export type BatchOperationStatus = typeof BatchOperationStatus[keyof typeof BatchOperationStatus];


/**
 * 
 * @export
 * @interface BatchOperations
 */
export interface BatchOperations {
    /**
     * 
     * @type {number}
     * @memberof BatchOperations
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BatchOperations
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BatchOperations
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BatchOperation>}
     * @memberof BatchOperations
     */
    'results': Array<BatchOperation>;
}
/**
 * 
 * @export
 * @interface BatchOrderData
 */
export interface BatchOrderData {
    /**
     * The list of orders to process.
     * @type {Array<OrderData>}
     * @memberof BatchOrderData
     */
    'orders': Array<OrderData>;
}
/**
 * 
 * @export
 * @interface BatchShipmentData
 */
export interface BatchShipmentData {
    /**
     * The list of shipments to process.
     * @type {Array<ShipmentData>}
     * @memberof BatchShipmentData
     */
    'shipments': Array<ShipmentData>;
}
/**
 * 
 * @export
 * @interface BatchTrackerData
 */
export interface BatchTrackerData {
    /**
     * The list of tracking info to process.
     * @type {Array<TrackingData>}
     * @memberof BatchTrackerData
     */
    'trackers': Array<TrackingData>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BlankEnum = {
    Empty: ''
} as const;

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


/**
 * 
 * @export
 * @interface CarrierList
 */
export interface CarrierList {
    /**
     * 
     * @type {number}
     * @memberof CarrierList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CarrierList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CarrierList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CarrierSettings>}
     * @memberof CarrierList
     */
    'results': Array<CarrierSettings>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CarrierNameEnum = {
    AmazonMws: 'amazon_mws',
    Aramex: 'aramex',
    Australiapost: 'australiapost',
    Canadapost: 'canadapost',
    Canpar: 'canpar',
    Chronopost: 'chronopost',
    DhlExpress: 'dhl_express',
    DhlPoland: 'dhl_poland',
    DhlUniversal: 'dhl_universal',
    Dicom: 'dicom',
    Dpdhl: 'dpdhl',
    Easypost: 'easypost',
    Eshipper: 'eshipper',
    Fedex: 'fedex',
    Freightcom: 'freightcom',
    Generic: 'generic',
    Purolator: 'purolator',
    Royalmail: 'royalmail',
    Sendle: 'sendle',
    SfExpress: 'sf_express',
    Tnt: 'tnt',
    Ups: 'ups',
    UpsFreight: 'ups_freight',
    Usps: 'usps',
    UspsInternational: 'usps_international',
    Yanwen: 'yanwen',
    Yunexpress: 'yunexpress'
} as const;

export type CarrierNameEnum = typeof CarrierNameEnum[keyof typeof CarrierNameEnum];


/**
 * 
 * @export
 * @interface CarrierSettings
 */
export interface CarrierSettings {
    /**
     * A unique address identifier
     * @type {string}
     * @memberof CarrierSettings
     */
    'id': string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof CarrierSettings
     */
    'object_type'?: string;
    /**
     * Indicates a specific carrier configuration name.
     * @type {string}
     * @memberof CarrierSettings
     */
    'carrier_id': string;
    /**
     * Indicates a carrier (type)
     * @type {CarrierNameEnum}
     * @memberof CarrierSettings
     */
    'carrier_name': CarrierNameEnum;
    /**
     * The carrier verbose name.
     * @type {string}
     * @memberof CarrierSettings
     */
    'display_name'?: string;
    /**
     * The test flag indicates whether to use a carrier configured for test.
     * @type {boolean}
     * @memberof CarrierSettings
     */
    'test_mode': boolean;
    /**
     * The active flag indicates whether the carrier account is active or not.
     * @type {boolean}
     * @memberof CarrierSettings
     */
    'active': boolean;
    /**
     * The carrier supported and enabled capabilities.
     * @type {Array<string>}
     * @memberof CarrierSettings
     */
    'capabilities'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * The charge description
     * @type {string}
     * @memberof Charge
     */
    'name'?: string | null;
    /**
     * The charge monetary value
     * @type {number}
     * @memberof Charge
     */
    'amount'?: number | null;
    /**
     * The charge amount currency
     * @type {string}
     * @memberof Charge
     */
    'currency'?: string | null;
}
/**
 * 
 * @export
 * @interface Commodity
 */
export interface Commodity {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Commodity
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof Commodity
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {WeightUnitEnum}
     * @memberof Commodity
     */
    'weight_unit': WeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof Commodity
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof Commodity
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof Commodity
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof Commodity
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof Commodity
     */
    'value_amount'?: number | null;
    /**
     * 
     * @type {CommodityValueCurrency}
     * @memberof Commodity
     */
    'value_currency'?: CommodityValueCurrency | null;
    /**
     * 
     * @type {CommodityOriginCountry}
     * @memberof Commodity
     */
    'origin_country'?: CommodityOriginCountry | null;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof Commodity
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         
     * @type {{ [key: string]: any; }}
     * @memberof Commodity
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Commodity
     */
    'object_type'?: string;
}
/**
 * 
 * @export
 * @interface CommodityData
 */
export interface CommodityData {
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof CommodityData
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {WeightUnitEnum}
     * @memberof CommodityData
     */
    'weight_unit': WeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof CommodityData
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof CommodityData
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof CommodityData
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof CommodityData
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof CommodityData
     */
    'value_amount'?: number | null;
    /**
     * 
     * @type {CommodityValueCurrency}
     * @memberof CommodityData
     */
    'value_currency'?: CommodityValueCurrency | null;
    /**
     * 
     * @type {CommodityOriginCountry}
     * @memberof CommodityData
     */
    'origin_country'?: CommodityOriginCountry | null;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof CommodityData
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         
     * @type {{ [key: string]: any; }}
     * @memberof CommodityData
     */
    'metadata'?: { [key: string]: any; } | null;
}
/**
 * @type CommodityOriginCountry
 * The origin or manufacture country
 * @export
 */
export type CommodityOriginCountry = CountryEnum | NullEnum;

/**
 * @type CommodityValueCurrency
 * The currency of the commodity value amount
 * @export
 */
export type CommodityValueCurrency = CurrencyEnum | NullEnum;

/**
 * 
 * @export
 * @enum {string}
 */

export const ContentTypeEnum = {
    Documents: 'documents',
    Gift: 'gift',
    Sample: 'sample',
    Merchandise: 'merchandise',
    ReturnMerchandise: 'return_merchandise',
    Other: 'other'
} as const;

export type ContentTypeEnum = typeof ContentTypeEnum[keyof typeof ContentTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const CountryEnum = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    An: 'AN',
    Ao: 'AO',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Ic: 'IC',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    In: 'IN',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kp: 'KP',
    Kr: 'KR',
    Kv: 'KV',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pr: 'PR',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tl: 'TL',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Ws: 'WS',
    Xb: 'XB',
    Xc: 'XC',
    Xe: 'XE',
    Xm: 'XM',
    Xn: 'XN',
    Xs: 'XS',
    Xy: 'XY',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type CountryEnum = typeof CountryEnum[keyof typeof CountryEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const CurrencyEnum = {
    Eur: 'EUR',
    Aed: 'AED',
    Usd: 'USD',
    Xcd: 'XCD',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Xof: 'XOF',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Xaf: 'XAF',
    Chf: 'CHF',
    Nzd: 'NZD',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Fjd: 'FJD',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Xpf: 'XPF',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Omr: 'OMR',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Srd: 'SRD',
    Ssp: 'SSP',
    Std: 'STD',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Yer: 'YER',
    Zar: 'ZAR'
} as const;

export type CurrencyEnum = typeof CurrencyEnum[keyof typeof CurrencyEnum];


/**
 * 
 * @export
 * @interface Customs
 */
export interface Customs {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Customs
     */
    'id'?: string;
    /**
     * The parcel content items
     * @type {Array<Commodity>}
     * @memberof Customs
     */
    'commodities'?: Array<Commodity>;
    /**
     * 
     * @type {CustomsDuty}
     * @memberof Customs
     */
    'duty'?: CustomsDuty | null;
    /**
     * 
     * @type {CustomsDutyBillingAddress}
     * @memberof Customs
     */
    'duty_billing_address'?: CustomsDutyBillingAddress | null;
    /**
     * 
     * @type {CustomsContentType}
     * @memberof Customs
     */
    'content_type'?: CustomsContentType | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'content_description'?: string | null;
    /**
     * 
     * @type {CustomsIncoterm}
     * @memberof Customs
     */
    'incoterm'?: CustomsIncoterm | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof Customs
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof Customs
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof Customs
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof Customs
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof Customs
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Customs
     */
    'object_type'?: string;
}
/**
 * @type CustomsContentType
 * @export
 */
export type CustomsContentType = BlankEnum | ContentTypeEnum | NullEnum;

/**
 * 
 * @export
 * @interface CustomsData
 */
export interface CustomsData {
    /**
     * The parcel content items
     * @type {Array<CommodityData>}
     * @memberof CustomsData
     */
    'commodities': Array<CommodityData>;
    /**
     * 
     * @type {CustomsDuty}
     * @memberof CustomsData
     */
    'duty'?: CustomsDuty | null;
    /**
     * 
     * @type {CustomsDataDutyBillingAddress}
     * @memberof CustomsData
     */
    'duty_billing_address'?: CustomsDataDutyBillingAddress | null;
    /**
     * 
     * @type {CustomsContentType}
     * @memberof CustomsData
     */
    'content_type'?: CustomsContentType | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'content_description'?: string | null;
    /**
     * 
     * @type {CustomsIncoterm}
     * @memberof CustomsData
     */
    'incoterm'?: CustomsIncoterm | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof CustomsData
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof CustomsData
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof CustomsData
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof CustomsData
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof CustomsData
     */
    'options'?: { [key: string]: any; };
}
/**
 * The duty payor address.
 * @export
 * @interface CustomsDataDutyBillingAddress
 */
export interface CustomsDataDutyBillingAddress {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof CustomsDataDutyBillingAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof CustomsDataDutyBillingAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof CustomsDataDutyBillingAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof CustomsDataDutyBillingAddress
     */
    'validate_location'?: boolean | null;
}
/**
 * The payment details.<br/>         **Note that this is required for a Dutiable parcel shipped internationally.**         
 * @export
 * @interface CustomsDuty
 */
export interface CustomsDuty {
    /**
     * 
     * @type {DutyPaidBy}
     * @memberof CustomsDuty
     */
    'paid_by'?: DutyPaidBy | null;
    /**
     * 
     * @type {DutyCurrency}
     * @memberof CustomsDuty
     */
    'currency'?: DutyCurrency | null;
    /**
     * The package declared value
     * @type {number}
     * @memberof CustomsDuty
     */
    'declared_value'?: number | null;
    /**
     * The duty payment account number
     * @type {string}
     * @memberof CustomsDuty
     */
    'account_number'?: string | null;
}
/**
 * The duty payor address.
 * @export
 * @interface CustomsDutyBillingAddress
 */
export interface CustomsDutyBillingAddress {
    /**
     * A unique identifier
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof CustomsDutyBillingAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof CustomsDutyBillingAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof CustomsDutyBillingAddress
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof CustomsDutyBillingAddress
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof CustomsDutyBillingAddress
     */
    'validation'?: AddressValidation | null;
}
/**
 * @type CustomsIncoterm
 * The customs \'term of trade\' also known as \'incoterm\'
 * @export
 */
export type CustomsIncoterm = IncotermEnum | NullEnum;

/**
 * 
 * @export
 * @interface CustomsList
 */
export interface CustomsList {
    /**
     * 
     * @type {number}
     * @memberof CustomsList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Customs>}
     * @memberof CustomsList
     */
    'results': Array<Customs>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DimensionUnitEnum = {
    Cm: 'CM',
    In: 'IN'
} as const;

export type DimensionUnitEnum = typeof DimensionUnitEnum[keyof typeof DimensionUnitEnum];


/**
 * 
 * @export
 * @interface DocumentDetails
 */
export interface DocumentDetails {
    /**
     * The uploaded document id.
     * @type {string}
     * @memberof DocumentDetails
     */
    'document_id'?: string;
    /**
     * The uploaded document file name.
     * @type {string}
     * @memberof DocumentDetails
     */
    'file_name'?: string;
}
/**
 * 
 * @export
 * @interface DocumentFileData
 */
export interface DocumentFileData {
    /**
     * A base64 file to upload
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_file': string;
    /**
     * A file name
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_name': string;
    /**
     * Shipping document type
     * @type {string}
     * @memberof DocumentFileData
     */
    'doc_type'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentUploadData
 */
export interface DocumentUploadData {
    /**
     * The documents related shipment.
     * @type {string}
     * @memberof DocumentUploadData
     */
    'shipment_id': string;
    /**
     * Shipping document files
     * @type {Array<DocumentFileData>}
     * @memberof DocumentUploadData
     */
    'document_files': Array<DocumentFileData>;
    /**
     * Shipping document file reference
     * @type {string}
     * @memberof DocumentUploadData
     */
    'reference'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentUploadRecord
 */
export interface DocumentUploadRecord {
    /**
     * A unique identifier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'id'?: string;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'carrier_id'?: string | null;
    /**
     * the carrier shipping document ids
     * @type {Array<DocumentDetails>}
     * @memberof DocumentUploadRecord
     */
    'documents'?: Array<DocumentDetails>;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof DocumentUploadRecord
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Shipping document file reference
     * @type {string}
     * @memberof DocumentUploadRecord
     */
    'reference'?: string | null;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof DocumentUploadRecord
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface DocumentUploadRecords
 */
export interface DocumentUploadRecords {
    /**
     * 
     * @type {number}
     * @memberof DocumentUploadRecords
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadRecords
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadRecords
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<DocumentUploadRecord>}
     * @memberof DocumentUploadRecords
     */
    'results': Array<DocumentUploadRecord>;
}
/**
 * 
 * @export
 * @interface Documents
 */
export interface Documents {
    /**
     * The shipment label in base64 string
     * @type {string}
     * @memberof Documents
     */
    'label'?: string | null;
    /**
     * The shipment invoice in base64 string
     * @type {string}
     * @memberof Documents
     */
    'invoice'?: string | null;
}
/**
 * 
 * @export
 * @interface Duty
 */
export interface Duty {
    /**
     * 
     * @type {DutyPaidBy}
     * @memberof Duty
     */
    'paid_by'?: DutyPaidBy | null;
    /**
     * 
     * @type {DutyCurrency}
     * @memberof Duty
     */
    'currency'?: DutyCurrency | null;
    /**
     * The package declared value
     * @type {number}
     * @memberof Duty
     */
    'declared_value'?: number | null;
    /**
     * The duty payment account number
     * @type {string}
     * @memberof Duty
     */
    'account_number'?: string | null;
}
/**
 * @type DutyCurrency
 * The declared value currency
 * @export
 */
export type DutyCurrency = BlankEnum | CurrencyEnum | NullEnum;

/**
 * @type DutyPaidBy
 * The duty payer
 * @export
 */
export type DutyPaidBy = BlankEnum | NullEnum | PaidByEnum;

/**
 * 
 * @export
 * @enum {string}
 */

export const EnabledEventsEnum = {
    All: 'all',
    ShipmentPurchased: 'shipment_purchased',
    ShipmentCancelled: 'shipment_cancelled',
    ShipmentFulfilled: 'shipment_fulfilled',
    TrackerCreated: 'tracker_created',
    TrackerUpdated: 'tracker_updated',
    OrderCreated: 'order_created',
    OrderUpdated: 'order_updated',
    OrderFulfilled: 'order_fulfilled',
    OrderCancelled: 'order_cancelled',
    OrderDelivered: 'order_delivered',
    BatchQueued: 'batch_queued',
    BatchFailed: 'batch_failed',
    BatchRunning: 'batch_running',
    BatchCompleted: 'batch_completed'
} as const;

export type EnabledEventsEnum = typeof EnabledEventsEnum[keyof typeof EnabledEventsEnum];


/**
 * 
 * @export
 * @interface ErrorMessages
 */
export interface ErrorMessages {
    /**
     * The list of error messages
     * @type {Array<Message>}
     * @memberof ErrorMessages
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The list of API errors
     * @type {Array<APIError>}
     * @memberof ErrorResponse
     */
    'errors'?: Array<APIError>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IncotermEnum = {
    Cfr: 'CFR',
    Cif: 'CIF',
    Cip: 'CIP',
    Cpt: 'CPT',
    Daf: 'DAF',
    Ddp: 'DDP',
    Ddu: 'DDU',
    Deq: 'DEQ',
    Des: 'DES',
    Exw: 'EXW',
    Fas: 'FAS',
    Fca: 'FCA',
    Fob: 'FOB'
} as const;

export type IncotermEnum = typeof IncotermEnum[keyof typeof IncotermEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const LabelTypeEnum = {
    Pdf: 'PDF',
    Zpl: 'ZPL',
    Png: 'PNG'
} as const;

export type LabelTypeEnum = typeof LabelTypeEnum[keyof typeof LabelTypeEnum];


/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * A unique identifier
     * @type {string}
     * @memberof LineItem
     */
    'id'?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof LineItem
     */
    'weight': number;
    /**
     * The commodity\'s weight unit
     * @type {WeightUnitEnum}
     * @memberof LineItem
     */
    'weight_unit': WeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof LineItem
     */
    'description'?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof LineItem
     */
    'quantity'?: number;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof LineItem
     */
    'sku'?: string | null;
    /**
     * The commodity\'s hs_code number
     * @type {string}
     * @memberof LineItem
     */
    'hs_code'?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof LineItem
     */
    'value_amount'?: number | null;
    /**
     * 
     * @type {CommodityValueCurrency}
     * @memberof LineItem
     */
    'value_currency'?: CommodityValueCurrency | null;
    /**
     * 
     * @type {CommodityOriginCountry}
     * @memberof LineItem
     */
    'origin_country'?: CommodityOriginCountry | null;
    /**
     * The id of the related order line item.
     * @type {string}
     * @memberof LineItem
     */
    'parent_id'?: string | null;
    /**
     * <details>         <summary>Commodity user references metadata.</summary>          {             \"part_number\": \"5218487281\",             \"reference1\": \"# ref 1\",             \"reference2\": \"# ref 2\",             \"reference3\": \"# ref 3\",             ...         }         
     * @type {{ [key: string]: any; }}
     * @memberof LineItem
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof LineItem
     */
    'object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'unfulfilled_quantity'?: number;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The error or warning message
     * @type {string}
     * @memberof Message
     */
    'message'?: string;
    /**
     * The message code
     * @type {string}
     * @memberof Message
     */
    'code'?: string;
    /**
     * any additional details
     * @type {{ [key: string]: any; }}
     * @memberof Message
     */
    'details'?: { [key: string]: any; };
    /**
     * The targeted carrier
     * @type {string}
     * @memberof Message
     */
    'carrier_name'?: string;
    /**
     * The targeted carrier name (unique identifier)
     * @type {string}
     * @memberof Message
     */
    'carrier_id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NullEnum = {
    Null: 'null'
} as const;

export type NullEnum = typeof NullEnum[keyof typeof NullEnum];


/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * Operation performed
     * @type {string}
     * @memberof Operation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof Operation
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface OperationConfirmation
 */
export interface OperationConfirmation {
    /**
     * Operation performed
     * @type {string}
     * @memberof OperationConfirmation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof OperationConfirmation
     */
    'success': boolean;
    /**
     * The operation carrier
     * @type {string}
     * @memberof OperationConfirmation
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof OperationConfirmation
     */
    'carrier_id': string;
}
/**
 * 
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof OperationResponse
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {OperationResponseConfirmation}
     * @memberof OperationResponse
     */
    'confirmation'?: OperationResponseConfirmation;
}
/**
 * The operation details
 * @export
 * @interface OperationResponseConfirmation
 */
export interface OperationResponseConfirmation {
    /**
     * Operation performed
     * @type {string}
     * @memberof OperationResponseConfirmation
     */
    'operation': string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof OperationResponseConfirmation
     */
    'success': boolean;
    /**
     * The operation carrier
     * @type {string}
     * @memberof OperationResponseConfirmation
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof OperationResponseConfirmation
     */
    'carrier_id': string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Order
     */
    'object_type'?: string;
    /**
     * The source\' order id.
     * @type {string}
     * @memberof Order
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     * @type {string}
     * @memberof Order
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.
     * @type {string}
     * @memberof Order
     */
    'source'?: string;
    /**
     * The order status.
     * @type {OrderStatusEnum}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {OrderShippingTo}
     * @memberof Order
     */
    'shipping_to': OrderShippingTo;
    /**
     * 
     * @type {OrderShippingFrom}
     * @memberof Order
     */
    'shipping_from'?: OrderShippingFrom | null;
    /**
     * 
     * @type {OrderBillingAddress}
     * @memberof Order
     */
    'billing_address'?: OrderBillingAddress | null;
    /**
     * The order line items.
     * @type {Array<LineItem>}
     * @memberof Order
     */
    'line_items': Array<LineItem>;
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"third_party\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],         }         
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * system related metadata.
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * User metadata for the order.
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The shipments associated with the order.
     * @type {Array<Shipment>}
     * @memberof Order
     */
    'shipments'?: Array<Shipment>;
    /**
     * Specify whether the order is in test mode or not.
     * @type {boolean}
     * @memberof Order
     */
    'test_mode': boolean;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
}
/**
 * The customer\' or shipping billing address.
 * @export
 * @interface OrderBillingAddress
 */
export interface OrderBillingAddress {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof OrderBillingAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof OrderBillingAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof OrderBillingAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof OrderBillingAddress
     */
    'validate_location'?: boolean | null;
}
/**
 * 
 * @export
 * @interface OrderData
 */
export interface OrderData {
    /**
     * The source\' order id.
     * @type {string}
     * @memberof OrderData
     */
    'order_id': string;
    /**
     * The order date. format: `YYYY-MM-DD`
     * @type {string}
     * @memberof OrderData
     */
    'order_date'?: string | null;
    /**
     * The order\'s source.<br/>         e.g. API, POS, ERP, Shopify, Woocommerce, etc.         
     * @type {string}
     * @memberof OrderData
     */
    'source'?: string;
    /**
     * 
     * @type {OrderDataShippingTo}
     * @memberof OrderData
     */
    'shipping_to': OrderDataShippingTo;
    /**
     * 
     * @type {OrderDataShippingFrom}
     * @memberof OrderData
     */
    'shipping_from'?: OrderDataShippingFrom | null;
    /**
     * 
     * @type {OrderBillingAddress}
     * @memberof OrderData
     */
    'billing_address'?: OrderBillingAddress | null;
    /**
     * The order line items.
     * @type {Array<CommodityData>}
     * @memberof OrderData
     */
    'line_items': Array<CommodityData>;
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"third_party\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],         }         
     * @type {{ [key: string]: any; }}
     * @memberof OrderData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the order.
     * @type {{ [key: string]: any; }}
     * @memberof OrderData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * The origin or warehouse address of the order items.
 * @export
 * @interface OrderDataShippingFrom
 */
export interface OrderDataShippingFrom {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof OrderDataShippingFrom
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof OrderDataShippingFrom
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof OrderDataShippingFrom
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof OrderDataShippingFrom
     */
    'validate_location'?: boolean | null;
}
/**
 * The customer or recipient address for the order.
 * @export
 * @interface OrderDataShippingTo
 */
export interface OrderDataShippingTo {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof OrderDataShippingTo
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof OrderDataShippingTo
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof OrderDataShippingTo
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof OrderDataShippingTo
     */
    'validate_location'?: boolean | null;
}
/**
 * 
 * @export
 * @interface OrderList
 */
export interface OrderList {
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderList
     */
    'results': Array<Order>;
}
/**
 * The origin or warehouse address of the order items.
 * @export
 * @interface OrderShippingFrom
 */
export interface OrderShippingFrom {
    /**
     * A unique identifier
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof OrderShippingFrom
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof OrderShippingFrom
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof OrderShippingFrom
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof OrderShippingFrom
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof OrderShippingFrom
     */
    'validation'?: AddressValidation | null;
}
/**
 * The customer address for the order.
 * @export
 * @interface OrderShippingTo
 */
export interface OrderShippingTo {
    /**
     * A unique identifier
     * @type {string}
     * @memberof OrderShippingTo
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingTo
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingTo
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof OrderShippingTo
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof OrderShippingTo
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingTo
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof OrderShippingTo
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof OrderShippingTo
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof OrderShippingTo
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof OrderShippingTo
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof OrderShippingTo
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof OrderShippingTo
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof OrderShippingTo
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof OrderShippingTo
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof OrderShippingTo
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof OrderShippingTo
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof OrderShippingTo
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof OrderShippingTo
     */
    'validation'?: AddressValidation | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatusEnum = {
    Unfulfilled: 'unfulfilled',
    Cancelled: 'cancelled',
    Fulfilled: 'fulfilled',
    Delivered: 'delivered',
    Partial: 'partial'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];


/**
 * 
 * @export
 * @interface OrderUpdateData
 */
export interface OrderUpdateData {
    /**
     * <details>         <summary>The options available for the order shipments.</summary>          {             \"currency\": \"USD\",             \"paid_by\": \"third_party\",             \"payment_account_number\": \"123456789\",             \"duty_paid_by\": \"recipient\",             \"duty_account_number\": \"123456789\",             \"invoice_number\": \"123456789\",             \"invoice_date\": \"2020-01-01\",             \"single_item_per_parcel\": true,             \"carrier_ids\": [\"canadapost-test\"],         }         
     * @type {{ [key: string]: any; }}
     * @memberof OrderUpdateData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof OrderUpdateData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PaidByEnum = {
    Sender: 'sender',
    Recipient: 'recipient',
    ThirdParty: 'third_party'
} as const;

export type PaidByEnum = typeof PaidByEnum[keyof typeof PaidByEnum];


/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Parcel
     */
    'id'?: string;
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof Parcel
     */
    'weight': number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof Parcel
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof Parcel
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof Parcel
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof Parcel
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     * @type {string}
     * @memberof Parcel
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof Parcel
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof Parcel
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof Parcel
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {WeightUnitEnum}
     * @memberof Parcel
     */
    'weight_unit': WeightUnitEnum;
    /**
     * 
     * @type {ParcelDimensionUnit}
     * @memberof Parcel
     */
    'dimension_unit'?: ParcelDimensionUnit | null;
    /**
     * The parcel items.
     * @type {Array<Commodity>}
     * @memberof Parcel
     */
    'items'?: Array<Commodity>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     * @type {string}
     * @memberof Parcel
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof Parcel
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof Parcel
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Parcel
     */
    'object_type'?: string;
}
/**
 * 
 * @export
 * @interface ParcelData
 */
export interface ParcelData {
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof ParcelData
     */
    'weight': number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof ParcelData
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof ParcelData
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof ParcelData
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof ParcelData
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     * @type {string}
     * @memberof ParcelData
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof ParcelData
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof ParcelData
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof ParcelData
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {WeightUnitEnum}
     * @memberof ParcelData
     */
    'weight_unit': WeightUnitEnum;
    /**
     * 
     * @type {ParcelDimensionUnit}
     * @memberof ParcelData
     */
    'dimension_unit'?: ParcelDimensionUnit | null;
    /**
     * The parcel items.
     * @type {Array<CommodityData>}
     * @memberof ParcelData
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     * @type {string}
     * @memberof ParcelData
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof ParcelData
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof ParcelData
     */
    'options'?: { [key: string]: any; };
}
/**
 * @type ParcelDimensionUnit
 * The parcel\'s dimension unit
 * @export
 */
export type ParcelDimensionUnit = DimensionUnitEnum | NullEnum;

/**
 * 
 * @export
 * @interface ParcelList
 */
export interface ParcelList {
    /**
     * 
     * @type {number}
     * @memberof ParcelList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Parcel>}
     * @memberof ParcelList
     */
    'results': Array<Parcel>;
}
/**
 * 
 * @export
 * @interface PatchedAddressData
 */
export interface PatchedAddressData {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof PatchedAddressData
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof PatchedAddressData
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof PatchedAddressData
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof PatchedAddressData
     */
    'country_code'?: CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof PatchedAddressData
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof PatchedAddressData
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof PatchedAddressData
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof PatchedAddressData
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof PatchedAddressData
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PatchedAddressData
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof PatchedAddressData
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof PatchedAddressData
     */
    'validate_location'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PatchedCustomsData
 */
export interface PatchedCustomsData {
    /**
     * The parcel content items
     * @type {Array<CommodityData>}
     * @memberof PatchedCustomsData
     */
    'commodities'?: Array<CommodityData>;
    /**
     * 
     * @type {CustomsDuty}
     * @memberof PatchedCustomsData
     */
    'duty'?: CustomsDuty | null;
    /**
     * 
     * @type {CustomsDataDutyBillingAddress}
     * @memberof PatchedCustomsData
     */
    'duty_billing_address'?: CustomsDataDutyBillingAddress | null;
    /**
     * 
     * @type {CustomsContentType}
     * @memberof PatchedCustomsData
     */
    'content_type'?: CustomsContentType | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomsData
     */
    'content_description'?: string | null;
    /**
     * 
     * @type {CustomsIncoterm}
     * @memberof PatchedCustomsData
     */
    'incoterm'?: CustomsIncoterm | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof PatchedCustomsData
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof PatchedCustomsData
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof PatchedCustomsData
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof PatchedCustomsData
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomsData
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof PatchedCustomsData
     */
    'options'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PatchedParcelData
 */
export interface PatchedParcelData {
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof PatchedParcelData
     */
    'weight'?: number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof PatchedParcelData
     */
    'width'?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof PatchedParcelData
     */
    'height'?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof PatchedParcelData
     */
    'length'?: number | null;
    /**
     * The parcel\'s packaging type.<br/>         **Note that the packaging is optional when using a package preset.**<br/>         values: <br/>         `envelope` `pak` `tube` `pallet` `small_box` `medium_box` `your_packaging`<br/>         For carrier specific packaging types, please consult the reference.         
     * @type {string}
     * @memberof PatchedParcelData
     */
    'packaging_type'?: string | null;
    /**
     * The parcel\'s package preset.<br/>         For carrier specific package presets, please consult the reference.         
     * @type {string}
     * @memberof PatchedParcelData
     */
    'package_preset'?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof PatchedParcelData
     */
    'description'?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof PatchedParcelData
     */
    'content'?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof PatchedParcelData
     */
    'is_document'?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {WeightUnitEnum}
     * @memberof PatchedParcelData
     */
    'weight_unit'?: WeightUnitEnum;
    /**
     * 
     * @type {ParcelDimensionUnit}
     * @memberof PatchedParcelData
     */
    'dimension_unit'?: ParcelDimensionUnit | null;
    /**
     * The parcel items.
     * @type {Array<CommodityData>}
     * @memberof PatchedParcelData
     */
    'items'?: Array<CommodityData>;
    /**
     * The parcel reference number.<br/>         (can be used as tracking number for custom carriers)         
     * @type {string}
     * @memberof PatchedParcelData
     */
    'reference_number'?: string | null;
    /**
     * The parcel\'s freight class for pallet and freight shipments.
     * @type {string}
     * @memberof PatchedParcelData
     */
    'freight_class'?: string | null;
    /**
     * <details>         <summary>Parcel specific options.</summary>          {             \"insurance\": \"100.00\",             \"insured_by\": \"carrier\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof PatchedParcelData
     */
    'options'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PatchedWebhookData
 */
export interface PatchedWebhookData {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof PatchedWebhookData
     */
    'url'?: string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof PatchedWebhookData
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<EnabledEventsEnum>}
     * @memberof PatchedWebhookData
     */
    'enabled_events'?: Array<EnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof PatchedWebhookData
     */
    'disabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The payor type
     * @type {PaidByEnum}
     * @memberof Payment
     */
    'paid_by'?: PaidByEnum;
    /**
     * 
     * @type {PaymentCurrency}
     * @memberof Payment
     */
    'currency'?: PaymentCurrency | null;
    /**
     * The payor account number
     * @type {string}
     * @memberof Payment
     */
    'account_number'?: string | null;
}
/**
 * @type PaymentCurrency
 * The payment amount currency
 * @export
 */
export type PaymentCurrency = BlankEnum | CurrencyEnum | NullEnum;

/**
 * 
 * @export
 * @interface Pickup
 */
export interface Pickup {
    /**
     * A unique pickup identifier
     * @type {string}
     * @memberof Pickup
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Pickup
     */
    'object_type'?: string;
    /**
     * The pickup carrier
     * @type {string}
     * @memberof Pickup
     */
    'carrier_name': string;
    /**
     * The pickup carrier configured name
     * @type {string}
     * @memberof Pickup
     */
    'carrier_id': string;
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof Pickup
     */
    'confirmation_number': string;
    /**
     * The pickup date
     * @type {string}
     * @memberof Pickup
     */
    'pickup_date'?: string | null;
    /**
     * 
     * @type {PickupPickupCharge}
     * @memberof Pickup
     */
    'pickup_charge'?: PickupPickupCharge | null;
    /**
     * The pickup expected ready time
     * @type {string}
     * @memberof Pickup
     */
    'ready_time'?: string | null;
    /**
     * The pickup expected closing or late time
     * @type {string}
     * @memberof Pickup
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {PickupAddress}
     * @memberof Pickup
     */
    'address': PickupAddress;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof Pickup
     */
    'parcels': Array<Parcel>;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof Pickup
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof Pickup
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof Pickup
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof Pickup
     */
    'metadata'?: { [key: string]: any; };
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Pickup
     */
    'test_mode': boolean;
}
/**
 * The pickup address
 * @export
 * @interface PickupAddress
 */
export interface PickupAddress {
    /**
     * A unique identifier
     * @type {string}
     * @memberof PickupAddress
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof PickupAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof PickupAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof PickupAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof PickupAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof PickupAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof PickupAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof PickupAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof PickupAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof PickupAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof PickupAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof PickupAddress
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof PickupAddress
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof PickupAddress
     */
    'validation'?: AddressValidation | null;
}
/**
 * 
 * @export
 * @interface PickupCancelData
 */
export interface PickupCancelData {
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelData
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface PickupCancelRequest
 */
export interface PickupCancelRequest {
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'confirmation_number': string;
    /**
     * 
     * @type {PickupCancelRequestAddress}
     * @memberof PickupCancelRequest
     */
    'address'?: PickupCancelRequestAddress;
    /**
     * The pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'pickup_date'?: string | null;
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelRequest
     */
    'reason'?: string;
}
/**
 * The pickup address
 * @export
 * @interface PickupCancelRequestAddress
 */
export interface PickupCancelRequestAddress {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof PickupCancelRequestAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof PickupCancelRequestAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof PickupCancelRequestAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof PickupCancelRequestAddress
     */
    'validate_location'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PickupData
 */
export interface PickupData {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupData
     */
    'pickup_date': string;
    /**
     * 
     * @type {PickupCancelRequestAddress}
     * @memberof PickupData
     */
    'address'?: PickupCancelRequestAddress;
    /**
     * The ready time for pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupData
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupData
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupData
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupData
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupData
     */
    'tracking_numbers': Array<string>;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof PickupData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PickupList
 */
export interface PickupList {
    /**
     * 
     * @type {number}
     * @memberof PickupList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Pickup>}
     * @memberof PickupList
     */
    'results': Array<Pickup>;
}
/**
 * The pickup cost details
 * @export
 * @interface PickupPickupCharge
 */
export interface PickupPickupCharge {
    /**
     * The charge description
     * @type {string}
     * @memberof PickupPickupCharge
     */
    'name'?: string | null;
    /**
     * The charge monetary value
     * @type {number}
     * @memberof PickupPickupCharge
     */
    'amount'?: number | null;
    /**
     * The charge amount currency
     * @type {string}
     * @memberof PickupPickupCharge
     */
    'currency'?: string | null;
}
/**
 * 
 * @export
 * @interface PickupRequest
 */
export interface PickupRequest {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupRequest
     */
    'pickup_date': string;
    /**
     * 
     * @type {PickupCancelRequestAddress}
     * @memberof PickupRequest
     */
    'address': PickupCancelRequestAddress;
    /**
     * The shipment parcels to pickup.
     * @type {Array<ParcelData>}
     * @memberof PickupRequest
     */
    'parcels': Array<ParcelData>;
    /**
     * The ready time for pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupRequest
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupRequest
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupRequest
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupRequest
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupRequest
     */
    'options'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface PickupResponse
 */
export interface PickupResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof PickupResponse
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {PickupResponsePickup}
     * @memberof PickupResponse
     */
    'pickup'?: PickupResponsePickup;
}
/**
 * The scheduled pickup\'s summary
 * @export
 * @interface PickupResponsePickup
 */
export interface PickupResponsePickup {
    /**
     * A unique pickup identifier
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'object_type'?: string;
    /**
     * The pickup carrier
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'carrier_name': string;
    /**
     * The pickup carrier configured name
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'carrier_id': string;
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'confirmation_number': string;
    /**
     * The pickup date
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'pickup_date'?: string | null;
    /**
     * 
     * @type {PickupPickupCharge}
     * @memberof PickupResponsePickup
     */
    'pickup_charge'?: PickupPickupCharge | null;
    /**
     * The pickup expected ready time
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'ready_time'?: string | null;
    /**
     * The pickup expected closing or late time
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'closing_time'?: string | null;
    /**
     * 
     * @type {PickupAddress}
     * @memberof PickupResponsePickup
     */
    'address': PickupAddress;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof PickupResponsePickup
     */
    'parcels': Array<Parcel>;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupResponsePickup
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupResponsePickup
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof PickupResponsePickup
     */
    'metadata'?: { [key: string]: any; };
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof PickupResponsePickup
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface PickupUpdateData
 */
export interface PickupUpdateData {
    /**
     * The expected pickup date.<br/>         Date Format: YYYY-MM-DD         
     * @type {string}
     * @memberof PickupUpdateData
     */
    'pickup_date'?: string;
    /**
     * 
     * @type {PickupCancelRequestAddress}
     * @memberof PickupUpdateData
     */
    'address'?: PickupCancelRequestAddress;
    /**
     * The ready time for pickup.
     * @type {string}
     * @memberof PickupUpdateData
     */
    'ready_time'?: string | null;
    /**
     * The closing or late time of the pickup
     * @type {string}
     * @memberof PickupUpdateData
     */
    'closing_time'?: string | null;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupUpdateData
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupUpdateData
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupUpdateData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupUpdateData
     */
    'tracking_numbers'?: Array<string>;
    /**
     * User metadata for the pickup
     * @type {{ [key: string]: any; }}
     * @memberof PickupUpdateData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateData
     */
    'confirmation_number': string;
}
/**
 * 
 * @export
 * @interface PickupUpdateRequest
 */
export interface PickupUpdateRequest {
    /**
     * The expected pickup date.<br/>         Date Format: `YYYY-MM-DD`         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'pickup_date': string;
    /**
     * 
     * @type {PickupAddress}
     * @memberof PickupUpdateRequest
     */
    'address': PickupAddress;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof PickupUpdateRequest
     */
    'parcels': Array<Parcel>;
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'confirmation_number': string;
    /**
     * The ready time for pickup.         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'ready_time': string;
    /**
     * The closing or late time of the pickup.<br/>         Time Format: `HH:MM`         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'closing_time': string;
    /**
     * The pickup instruction.<br/>         eg: Handle with care.         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'instruction'?: string | null;
    /**
     * The package(s) location.<br/>         eg: Behind the entrance door.         
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    'package_location'?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {{ [key: string]: any; }}
     * @memberof PickupUpdateRequest
     */
    'options'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Rate
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Rate
     */
    'object_type'?: string;
    /**
     * The rate\'s carrier
     * @type {string}
     * @memberof Rate
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof Rate
     */
    'carrier_id': string;
    /**
     * The rate monetary values currency code
     * @type {string}
     * @memberof Rate
     */
    'currency'?: string;
    /**
     * The carrier\'s rate (quote) service
     * @type {string}
     * @memberof Rate
     */
    'service'?: string | null;
    /**
     * The rate\'s monetary amount of the total charge.<br/>         This is the gross amount of the rate after adding the additional charges         
     * @type {number}
     * @memberof Rate
     */
    'total_charge'?: number;
    /**
     * The estimated delivery transit days
     * @type {number}
     * @memberof Rate
     */
    'transit_days'?: number | null;
    /**
     * list of the rate\'s additional charges
     * @type {Array<Charge>}
     * @memberof Rate
     */
    'extra_charges'?: Array<Charge>;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof Rate
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Rate
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface RateRequest
 */
export interface RateRequest {
    /**
     * 
     * @type {RateRequestShipper}
     * @memberof RateRequest
     */
    'shipper': RateRequestShipper;
    /**
     * 
     * @type {RateRequestShipper}
     * @memberof RateRequest
     */
    'recipient': RateRequestShipper;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof RateRequest
     */
    'parcels': Array<ParcelData>;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.         
     * @type {Array<string>}
     * @memberof RateRequest
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"shipment_date\": \"2020-01-01\",             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"signature_confirmation\": true,         }         
     * @type {{ [key: string]: any; }}
     * @memberof RateRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * The shipment reference
     * @type {string}
     * @memberof RateRequest
     */
    'reference'?: string | null;
    /**
     * The list of configured carriers you wish to get rates from.
     * @type {Array<string>}
     * @memberof RateRequest
     */
    'carrier_ids'?: Array<string> | null;
}
/**
 * The address of the party<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
 * @export
 * @interface RateRequestShipper
 */
export interface RateRequestShipper {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof RateRequestShipper
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof RateRequestShipper
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof RateRequestShipper
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof RateRequestShipper
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof RateRequestShipper
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof RateRequestShipper
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof RateRequestShipper
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof RateRequestShipper
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof RateRequestShipper
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof RateRequestShipper
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof RateRequestShipper
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof RateRequestShipper
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof RateRequestShipper
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof RateRequestShipper
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof RateRequestShipper
     */
    'validate_location'?: boolean | null;
}
/**
 * 
 * @export
 * @interface RateResponse
 */
export interface RateResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof RateResponse
     */
    'messages'?: Array<Message>;
    /**
     * The list of returned rates
     * @type {Array<Rate>}
     * @memberof RateResponse
     */
    'rates': Array<Rate>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResourceTypeEnum = {
    Orders: 'orders',
    Shipments: 'shipments',
    Trackers: 'trackers',
    Billing: 'billing'
} as const;

export type ResourceTypeEnum = typeof ResourceTypeEnum[keyof typeof ResourceTypeEnum];


/**
 * 
 * @export
 * @interface Shipment
 */
export interface Shipment {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Shipment
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Shipment
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof Shipment
     */
    'tracking_url'?: string | null;
    /**
     * 
     * @type {ShipmentShipper}
     * @memberof Shipment
     */
    'shipper': ShipmentShipper;
    /**
     * 
     * @type {ShipmentShipper}
     * @memberof Shipment
     */
    'recipient': ShipmentShipper;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof Shipment
     */
    'parcels': Array<Parcel>;
    /**
     * The carriers services requested for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof Shipment
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"shipment_date\": \"2020-01-01\",             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"signature_confirmation\": true,         }         
     * @type {{ [key: string]: any; }}
     * @memberof Shipment
     */
    'options'?: { [key: string]: any; };
    /**
     * 
     * @type {ShipmentPayment}
     * @memberof Shipment
     */
    'payment'?: ShipmentPayment;
    /**
     * 
     * @type {ShipmentBillingAddress}
     * @memberof Shipment
     */
    'billing_address'?: ShipmentBillingAddress | null;
    /**
     * 
     * @type {ShipmentCustoms}
     * @memberof Shipment
     */
    'customs'?: ShipmentCustoms | null;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof Shipment
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     * @type {string}
     * @memberof Shipment
     */
    'reference'?: string | null;
    /**
     * 
     * @type {ShipmentLabelType}
     * @memberof Shipment
     */
    'label_type'?: ShipmentLabelType | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof Shipment
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof Shipment
     */
    'tracker_id'?: string | null;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     * @type {string}
     * @memberof Shipment
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof Shipment
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof Shipment
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     * @type {ShipmentStatus}
     * @memberof Shipment
     */
    'status'?: ShipmentStatus;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof Shipment
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof Shipment
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof Shipment
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof Shipment
     */
    'shipment_identifier'?: string | null;
    /**
     * 
     * @type {ShipmentSelectedRate}
     * @memberof Shipment
     */
    'selected_rate'?: ShipmentSelectedRate | null;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof Shipment
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The selected service
     * @type {string}
     * @memberof Shipment
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof Shipment
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Shipment
     */
    'test_mode': boolean;
    /**
     * The shipment label URL
     * @type {string}
     * @memberof Shipment
     */
    'label_url'?: string | null;
    /**
     * The shipment invoice URL
     * @type {string}
     * @memberof Shipment
     */
    'invoice_url'?: string | null;
}
/**
 * The payor address.
 * @export
 * @interface ShipmentBillingAddress
 */
export interface ShipmentBillingAddress {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof ShipmentBillingAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof ShipmentBillingAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof ShipmentBillingAddress
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShipmentBillingAddress
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof ShipmentBillingAddress
     */
    'validation'?: AddressValidation | null;
}
/**
 * 
 * @export
 * @interface ShipmentCancelRequest
 */
export interface ShipmentCancelRequest {
    /**
     * The shipment identifier returned during creation
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'shipment_identifier': string;
    /**
     * The selected shipment service
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    'service'?: string | null;
    /**
     * Advanced carrier specific cancellation options
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentCancelRequest
     */
    'options'?: { [key: string]: any; };
}
/**
 * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
 * @export
 * @interface ShipmentCustoms
 */
export interface ShipmentCustoms {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShipmentCustoms
     */
    'id'?: string;
    /**
     * The parcel content items
     * @type {Array<Commodity>}
     * @memberof ShipmentCustoms
     */
    'commodities'?: Array<Commodity>;
    /**
     * 
     * @type {CustomsDuty}
     * @memberof ShipmentCustoms
     */
    'duty'?: CustomsDuty | null;
    /**
     * 
     * @type {CustomsDutyBillingAddress}
     * @memberof ShipmentCustoms
     */
    'duty_billing_address'?: CustomsDutyBillingAddress | null;
    /**
     * 
     * @type {CustomsContentType}
     * @memberof ShipmentCustoms
     */
    'content_type'?: CustomsContentType | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentCustoms
     */
    'content_description'?: string | null;
    /**
     * 
     * @type {CustomsIncoterm}
     * @memberof ShipmentCustoms
     */
    'incoterm'?: CustomsIncoterm | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof ShipmentCustoms
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof ShipmentCustoms
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof ShipmentCustoms
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof ShipmentCustoms
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentCustoms
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentCustoms
     */
    'options'?: { [key: string]: any; };
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShipmentCustoms
     */
    'object_type'?: string;
}
/**
 * 
 * @export
 * @interface ShipmentData
 */
export interface ShipmentData {
    /**
     * 
     * @type {ShipmentDataShipper}
     * @memberof ShipmentData
     */
    'shipper': ShipmentDataShipper;
    /**
     * 
     * @type {ShipmentDataShipper}
     * @memberof ShipmentData
     */
    'recipient': ShipmentDataShipper;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShipmentData
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"shipment_date\": \"2020-01-01\",             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"signature_confirmation\": true,         }         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentData
     */
    'options'?: { [key: string]: any; };
    /**
     * 
     * @type {ShipmentPayment}
     * @memberof ShipmentData
     */
    'payment'?: ShipmentPayment;
    /**
     * 
     * @type {ShipmentDataBillingAddress}
     * @memberof ShipmentData
     */
    'billing_address'?: ShipmentDataBillingAddress | null;
    /**
     * 
     * @type {ShipmentDataCustoms}
     * @memberof ShipmentData
     */
    'customs'?: ShipmentDataCustoms | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentData
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {LabelTypeEnum}
     * @memberof ShipmentData
     */
    'label_type'?: LabelTypeEnum;
    /**
     * **Specify a service to Buy a label in one call without rating.**
     * @type {string}
     * @memberof ShipmentData
     */
    'service'?: string;
    /**
     * The requested carrier service for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request         you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * The payor address.
 * @export
 * @interface ShipmentDataBillingAddress
 */
export interface ShipmentDataBillingAddress {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof ShipmentDataBillingAddress
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof ShipmentDataBillingAddress
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof ShipmentDataBillingAddress
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof ShipmentDataBillingAddress
     */
    'validate_location'?: boolean | null;
}
/**
 * The customs details.<br/>         **Note that this is required for the shipment of an international Dutiable parcel.**         
 * @export
 * @interface ShipmentDataCustoms
 */
export interface ShipmentDataCustoms {
    /**
     * The parcel content items
     * @type {Array<CommodityData>}
     * @memberof ShipmentDataCustoms
     */
    'commodities': Array<CommodityData>;
    /**
     * 
     * @type {CustomsDuty}
     * @memberof ShipmentDataCustoms
     */
    'duty'?: CustomsDuty | null;
    /**
     * 
     * @type {CustomsDataDutyBillingAddress}
     * @memberof ShipmentDataCustoms
     */
    'duty_billing_address'?: CustomsDataDutyBillingAddress | null;
    /**
     * 
     * @type {CustomsContentType}
     * @memberof ShipmentDataCustoms
     */
    'content_type'?: CustomsContentType | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentDataCustoms
     */
    'content_description'?: string | null;
    /**
     * 
     * @type {CustomsIncoterm}
     * @memberof ShipmentDataCustoms
     */
    'incoterm'?: CustomsIncoterm | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof ShipmentDataCustoms
     */
    'invoice'?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof ShipmentDataCustoms
     */
    'invoice_date'?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof ShipmentDataCustoms
     */
    'commercial_invoice'?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof ShipmentDataCustoms
     */
    'certify'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentDataCustoms
     */
    'signer'?: string | null;
    /**
     * <details>         <summary>Customs identification options.</summary>          {             \"aes\": \"5218487281\",             \"eel_pfc\": \"5218487281\",             \"license_number\": \"5218487281\",             \"certificate_number\": \"5218487281\",             \"nip_number\": \"5218487281\",             \"eori_number\": \"5218487281\",             \"vat_registration_number\": \"5218487281\",         }         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentDataCustoms
     */
    'options'?: { [key: string]: any; };
}
/**
 * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
 * @export
 * @interface ShipmentDataShipper
 */
export interface ShipmentDataShipper {
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof ShipmentDataShipper
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof ShipmentDataShipper
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof ShipmentDataShipper
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof ShipmentDataShipper
     */
    'validate_location'?: boolean | null;
}
/**
 * @type ShipmentLabelType
 * The shipment label file type.
 * @export
 */
export type ShipmentLabelType = BlankEnum | LabelTypeEnum | NullEnum;

/**
 * 
 * @export
 * @interface ShipmentList
 */
export interface ShipmentList {
    /**
     * 
     * @type {number}
     * @memberof ShipmentList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShipmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Shipment>}
     * @memberof ShipmentList
     */
    'results': Array<Shipment>;
}
/**
 * The payment details
 * @export
 * @interface ShipmentPayment
 */
export interface ShipmentPayment {
    /**
     * The payor type
     * @type {PaidByEnum}
     * @memberof ShipmentPayment
     */
    'paid_by'?: PaidByEnum;
    /**
     * 
     * @type {PaymentCurrency}
     * @memberof ShipmentPayment
     */
    'currency'?: PaymentCurrency | null;
    /**
     * The payor account number
     * @type {string}
     * @memberof ShipmentPayment
     */
    'account_number'?: string | null;
}
/**
 * 
 * @export
 * @interface ShipmentPurchaseData
 */
export interface ShipmentPurchaseData {
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'selected_rate_id': string;
    /**
     * The shipment label file type.
     * @type {LabelTypeEnum}
     * @memberof ShipmentPurchaseData
     */
    'label_type'?: LabelTypeEnum;
    /**
     * 
     * @type {ShipmentPurchaseDataPayment}
     * @memberof ShipmentPurchaseData
     */
    'payment'?: ShipmentPurchaseDataPayment;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentPurchaseData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * The payment details
 * @export
 * @interface ShipmentPurchaseDataPayment
 */
export interface ShipmentPurchaseDataPayment {
    /**
     * The payor type
     * @type {PaidByEnum}
     * @memberof ShipmentPurchaseDataPayment
     */
    'paid_by'?: PaidByEnum;
    /**
     * 
     * @type {PaymentCurrency}
     * @memberof ShipmentPurchaseDataPayment
     */
    'currency'?: PaymentCurrency | null;
    /**
     * The payor account number
     * @type {string}
     * @memberof ShipmentPurchaseDataPayment
     */
    'account_number'?: string | null;
}
/**
 * 
 * @export
 * @interface ShipmentRateData
 */
export interface ShipmentRateData {
    /**
     * The requested carrier service for the shipment.<br/>         Please consult [the reference](#operation/references) for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could         specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    'services'?: Array<string> | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentRateData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentRateData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * The shipment selected rate
 * @export
 * @interface ShipmentSelectedRate
 */
export interface ShipmentSelectedRate {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShipmentSelectedRate
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShipmentSelectedRate
     */
    'object_type'?: string;
    /**
     * The rate\'s carrier
     * @type {string}
     * @memberof ShipmentSelectedRate
     */
    'carrier_name': string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof ShipmentSelectedRate
     */
    'carrier_id': string;
    /**
     * The rate monetary values currency code
     * @type {string}
     * @memberof ShipmentSelectedRate
     */
    'currency'?: string;
    /**
     * The carrier\'s rate (quote) service
     * @type {string}
     * @memberof ShipmentSelectedRate
     */
    'service'?: string | null;
    /**
     * The rate\'s monetary amount of the total charge.<br/>         This is the gross amount of the rate after adding the additional charges         
     * @type {number}
     * @memberof ShipmentSelectedRate
     */
    'total_charge'?: number;
    /**
     * The estimated delivery transit days
     * @type {number}
     * @memberof ShipmentSelectedRate
     */
    'transit_days'?: number | null;
    /**
     * list of the rate\'s additional charges
     * @type {Array<Charge>}
     * @memberof ShipmentSelectedRate
     */
    'extra_charges'?: Array<Charge>;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentSelectedRate
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof ShipmentSelectedRate
     */
    'test_mode': boolean;
}
/**
 * The address of the party.<br/>         Origin address (ship from) for the **shipper**<br/>         Destination address (ship to) for the **recipient**         
 * @export
 * @interface ShipmentShipper
 */
export interface ShipmentShipper {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShipmentShipper
     */
    'id'?: string;
    /**
     * The address postal code         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentShipper
     */
    'postal_code'?: string | null;
    /**
     * The address city.         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentShipper
     */
    'city'?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof ShipmentShipper
     */
    'federal_tax_id'?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof ShipmentShipper
     */
    'state_tax_id'?: string | null;
    /**
     * Attention to         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentShipper
     */
    'person_name'?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof ShipmentShipper
     */
    'company_name'?: string | null;
    /**
     * The address country code
     * @type {CountryEnum}
     * @memberof ShipmentShipper
     */
    'country_code': CountryEnum;
    /**
     * The party email
     * @type {string}
     * @memberof ShipmentShipper
     */
    'email'?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof ShipmentShipper
     */
    'phone_number'?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof ShipmentShipper
     */
    'state_code'?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof ShipmentShipper
     */
    'suburb'?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof ShipmentShipper
     */
    'residential'?: boolean | null;
    /**
     * The address line with street number <br/>         **(required for shipment purchase)**         
     * @type {string}
     * @memberof ShipmentShipper
     */
    'address_line1'?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof ShipmentShipper
     */
    'address_line2'?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof ShipmentShipper
     */
    'validate_location'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShipmentShipper
     */
    'object_type'?: string;
    /**
     * 
     * @type {AddressValidation}
     * @memberof ShipmentShipper
     */
    'validation'?: AddressValidation | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ShipmentStatus = {
    Draft: 'draft',
    Purchased: 'purchased',
    Cancelled: 'cancelled',
    Shipped: 'shipped',
    InTransit: 'in_transit',
    Delivered: 'delivered'
} as const;

export type ShipmentStatus = typeof ShipmentStatus[keyof typeof ShipmentStatus];


/**
 * 
 * @export
 * @interface ShipmentUpdateData
 */
export interface ShipmentUpdateData {
    /**
     * The shipment label file type.
     * @type {LabelTypeEnum}
     * @memberof ShipmentUpdateData
     */
    'label_type'?: LabelTypeEnum;
    /**
     * 
     * @type {ShipmentPurchaseDataPayment}
     * @memberof ShipmentUpdateData
     */
    'payment'?: ShipmentPurchaseDataPayment;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"shipment_date\": \"2020-01-01\",             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"signature_confirmation\": true,         }         
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentUpdateData
     */
    'options'?: { [key: string]: any; } | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentUpdateData
     */
    'reference'?: string | null;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShipmentUpdateData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ShippingRequest
 */
export interface ShippingRequest {
    /**
     * 
     * @type {ShipmentDataShipper}
     * @memberof ShippingRequest
     */
    'shipper': ShipmentDataShipper;
    /**
     * 
     * @type {ShipmentDataShipper}
     * @memberof ShippingRequest
     */
    'recipient': ShipmentDataShipper;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShippingRequest
     */
    'parcels': Array<ParcelData>;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"shipment_date\": \"2020-01-01\",             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"signature_confirmation\": true,         }         
     * @type {{ [key: string]: any; }}
     * @memberof ShippingRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * 
     * @type {ShipmentPayment}
     * @memberof ShippingRequest
     */
    'payment'?: ShipmentPayment;
    /**
     * 
     * @type {ShipmentDataBillingAddress}
     * @memberof ShippingRequest
     */
    'billing_address'?: ShipmentDataBillingAddress | null;
    /**
     * 
     * @type {ShipmentDataCustoms}
     * @memberof ShippingRequest
     */
    'customs'?: ShipmentDataCustoms | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingRequest
     */
    'reference'?: string | null;
    /**
     * The shipment label file type.
     * @type {LabelTypeEnum}
     * @memberof ShippingRequest
     */
    'label_type'?: LabelTypeEnum;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingRequest
     */
    'selected_rate_id': string;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingRequest
     */
    'rates': Array<Rate>;
}
/**
 * 
 * @export
 * @interface ShippingResponse
 */
export interface ShippingResponse {
    /**
     * A unique identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'id'?: string;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof ShippingResponse
     */
    'object_type'?: string;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracking_url'?: string | null;
    /**
     * 
     * @type {ShipmentShipper}
     * @memberof ShippingResponse
     */
    'shipper': ShipmentShipper;
    /**
     * 
     * @type {ShipmentShipper}
     * @memberof ShippingResponse
     */
    'recipient': ShipmentShipper;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof ShippingResponse
     */
    'parcels': Array<Parcel>;
    /**
     * The carriers services requested for the shipment.<br/>         Please consult the reference for specific carriers services.<br/>         **Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier.**         
     * @type {Array<string>}
     * @memberof ShippingResponse
     */
    'services'?: Array<string> | null;
    /**
     * <details>         <summary>The options available for the shipment.</summary>          {             \"currency\": \"USD\",             \"insurance\": 100.00,             \"cash_on_delivery\": 30.00,             \"shipment_date\": \"2020-01-01\",             \"dangerous_good\": true,             \"declared_value\": 150.00,             \"email_notification\": true,             \"email_notification_to\": \"shipper@mail.com\",             \"signature_confirmation\": true,         }         
     * @type {{ [key: string]: any; }}
     * @memberof ShippingResponse
     */
    'options'?: { [key: string]: any; };
    /**
     * 
     * @type {ShipmentPayment}
     * @memberof ShippingResponse
     */
    'payment'?: ShipmentPayment;
    /**
     * 
     * @type {ShipmentBillingAddress}
     * @memberof ShippingResponse
     */
    'billing_address'?: ShipmentBillingAddress | null;
    /**
     * 
     * @type {ShipmentCustoms}
     * @memberof ShippingResponse
     */
    'customs'?: ShipmentCustoms | null;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingResponse
     */
    'rates'?: Array<Rate>;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingResponse
     */
    'reference'?: string | null;
    /**
     * 
     * @type {ShipmentLabelType}
     * @memberof ShippingResponse
     */
    'label_type'?: ShipmentLabelType | null;
    /**
     * The list of configured carriers you wish to get rates from.<br/>         **Note that the request will be sent to all carriers in nothing is specified**         
     * @type {Array<string>}
     * @memberof ShippingResponse
     */
    'carrier_ids'?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracker_id'?: string | null;
    /**
     * The shipment creation datetime.<br/>         Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz`         
     * @type {string}
     * @memberof ShippingResponse
     */
    'created_at': string;
    /**
     * User metadata for the shipment
     * @type {{ [key: string]: any; }}
     * @memberof ShippingResponse
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof ShippingResponse
     */
    'messages'?: Array<Message>;
    /**
     * The current Shipment status
     * @type {ShipmentStatus}
     * @memberof ShippingResponse
     */
    'status'?: ShipmentStatus;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof ShippingResponse
     */
    'carrier_name'?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'carrier_id'?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof ShippingResponse
     */
    'tracking_number'?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof ShippingResponse
     */
    'shipment_identifier'?: string | null;
    /**
     * 
     * @type {ShipmentSelectedRate}
     * @memberof ShippingResponse
     */
    'selected_rate'?: ShipmentSelectedRate | null;
    /**
     * 
     * @type {ShippingResponseDocs}
     * @memberof ShippingResponse
     */
    'docs'?: ShippingResponseDocs | null;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof ShippingResponse
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * The selected service
     * @type {string}
     * @memberof ShippingResponse
     */
    'service'?: string | null;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingResponse
     */
    'selected_rate_id'?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof ShippingResponse
     */
    'test_mode': boolean;
}
/**
 * The shipment documents
 * @export
 * @interface ShippingResponseDocs
 */
export interface ShippingResponseDocs {
    /**
     * The shipment label in base64 string
     * @type {string}
     * @memberof ShippingResponseDocs
     */
    'label'?: string | null;
    /**
     * The shipment invoice in base64 string
     * @type {string}
     * @memberof ShippingResponseDocs
     */
    'invoice'?: string | null;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TrackerList
 */
export interface TrackerList {
    /**
     * 
     * @type {number}
     * @memberof TrackerList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<TrackingStatus>}
     * @memberof TrackerList
     */
    'results': Array<TrackingStatus>;
}
/**
 * 
 * @export
 * @interface TrackingData
 */
export interface TrackingData {
    /**
     * The package tracking number
     * @type {string}
     * @memberof TrackingData
     */
    'tracking_number': string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingData
     */
    'carrier_name': string;
}
/**
 * 
 * @export
 * @interface TrackingEvent
 */
export interface TrackingEvent {
    /**
     * The tracking event\'s date
     * @type {string}
     * @memberof TrackingEvent
     */
    'date'?: string;
    /**
     * The tracking event\'s description
     * @type {string}
     * @memberof TrackingEvent
     */
    'description'?: string;
    /**
     * The tracking event\'s location
     * @type {string}
     * @memberof TrackingEvent
     */
    'location'?: string;
    /**
     * The tracking event\'s code
     * @type {string}
     * @memberof TrackingEvent
     */
    'code'?: string | null;
    /**
     * The tracking event\'s time
     * @type {string}
     * @memberof TrackingEvent
     */
    'time'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingResponse
 */
export interface TrackingResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingResponse
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {TrackingResponseTracking}
     * @memberof TrackingResponse
     */
    'tracking'?: TrackingResponseTracking;
}
/**
 * The tracking details retrieved
 * @export
 * @interface TrackingResponseTracking
 */
export interface TrackingResponseTracking {
    /**
     * A unique identifier
     * @type {string}
     * @memberof TrackingResponseTracking
     */
    'id'?: string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingResponseTracking
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     * @type {string}
     * @memberof TrackingResponseTracking
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof TrackingResponseTracking
     */
    'tracking_number': string;
    /**
     * The tracking details events
     * @type {Array<TrackingEvent>}
     * @memberof TrackingResponseTracking
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     * @type {boolean}
     * @memberof TrackingResponseTracking
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     * @type {boolean}
     * @memberof TrackingResponseTracking
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     * @type {TrackingStatusStatusEnum}
     * @memberof TrackingResponseTracking
     */
    'status'?: TrackingStatusStatusEnum;
    /**
     * The delivery estimated date
     * @type {string}
     * @memberof TrackingResponseTracking
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof TrackingResponseTracking
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof TrackingResponseTracking
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     * @type {{ [key: string]: any; }}
     * @memberof TrackingResponseTracking
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingResponseTracking
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface TrackingStatus
 */
export interface TrackingStatus {
    /**
     * A unique identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    'id'?: string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingStatus
     */
    'carrier_name': string;
    /**
     * The tracking carrier configured identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    'carrier_id': string;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof TrackingStatus
     */
    'tracking_number': string;
    /**
     * The tracking details events
     * @type {Array<TrackingEvent>}
     * @memberof TrackingStatus
     */
    'events'?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     * @type {boolean}
     * @memberof TrackingStatus
     */
    'delivered'?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     * @type {boolean}
     * @memberof TrackingStatus
     */
    'test_mode': boolean;
    /**
     * The current tracking status
     * @type {TrackingStatusStatusEnum}
     * @memberof TrackingStatus
     */
    'status'?: TrackingStatusStatusEnum;
    /**
     * The delivery estimated date
     * @type {string}
     * @memberof TrackingStatus
     */
    'estimated_delivery'?: string;
    /**
     * provider specific metadata
     * @type {{ [key: string]: any; }}
     * @memberof TrackingStatus
     */
    'meta'?: { [key: string]: any; } | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof TrackingStatus
     */
    'object_type'?: string;
    /**
     * User metadata for the tracker
     * @type {{ [key: string]: any; }}
     * @memberof TrackingStatus
     */
    'metadata'?: { [key: string]: any; };
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingStatus
     */
    'messages'?: Array<Message>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TrackingStatusStatusEnum = {
    Pending: 'pending',
    InTransit: 'in_transit',
    Incident: 'incident',
    Delivered: 'delivered',
    Unknown: 'unknown'
} as const;

export type TrackingStatusStatusEnum = typeof TrackingStatusStatusEnum[keyof typeof TrackingStatusStatusEnum];


/**
 * 
 * @export
 * @interface VerifiedTokenObtainPair
 */
export interface VerifiedTokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'access': string;
    /**
     * The OTP (One Time Password) token received by the user from the         configured Two Factor Authentication method.         
     * @type {string}
     * @memberof VerifiedTokenObtainPair
     */
    'otp_token': string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof Webhook
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<EnabledEventsEnum>}
     * @memberof Webhook
     */
    'enabled_events': Array<EnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof Webhook
     */
    'disabled'?: boolean | null;
    /**
     * Specifies the object type
     * @type {string}
     * @memberof Webhook
     */
    'object_type'?: string;
    /**
     * The datetime of the last event sent.
     * @type {string}
     * @memberof Webhook
     */
    'last_event_at'?: string | null;
    /**
     * Header signature secret
     * @type {string}
     * @memberof Webhook
     */
    'secret': string;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Webhook
     */
    'test_mode': boolean;
}
/**
 * 
 * @export
 * @interface WebhookData
 */
export interface WebhookData {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookData
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookData
     */
    'description'?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<EnabledEventsEnum>}
     * @memberof WebhookData
     */
    'enabled_events': Array<EnabledEventsEnum>;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof WebhookData
     */
    'disabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     * 
     * @type {number}
     * @memberof WebhookList
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    'results': Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookTestRequest
     */
    'payload': { [key: string]: any; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WeightUnitEnum = {
    Kg: 'KG',
    Lb: 'LB'
} as const;

export type WeightUnitEnum = typeof WeightUnitEnum[keyof typeof WeightUnitEnum];



/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (tokenObtainPair: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('authenticate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken: async (verifiedTokenObtainPair: VerifiedTokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifiedTokenObtainPair' is not null or undefined
            assertParamExists('getVerifiedToken', 'verifiedTokenObtainPair', verifiedTokenObtainPair)
            const localVarPath = `/api/token/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifiedTokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (tokenRefresh: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('refreshToken', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken: async (tokenVerify: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('verifyToken', 'tokenVerify', tokenVerify)
            const localVarPath = `/api/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(tokenObtainPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async data(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.data(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerifiedToken(verifiedTokenObtainPair: VerifiedTokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerifiedToken(verifiedTokenObtainPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(tokenRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyToken(tokenVerify: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyToken(tokenVerify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(tokenObtainPair: TokenObtainPair, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.authenticate(tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.data(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a verified JWT token pair by submitting a Two-Factor authentication code.
         * @summary Get verified JWT token
         * @param {VerifiedTokenObtainPair} verifiedTokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedToken(verifiedTokenObtainPair: VerifiedTokenObtainPair, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.getVerifiedToken(verifiedTokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instance Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(tokenRefresh: TokenRefresh, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.refreshToken(tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify an existent authentication token
         * @summary Verify token
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken(tokenVerify: TokenVerify, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.verifyToken(tokenVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticate operation in APIApi.
 * @export
 * @interface APIApiAuthenticateRequest
 */
export interface APIApiAuthenticateRequest {
    /**
     * 
     * @type {TokenObtainPair}
     * @memberof APIApiAuthenticate
     */
    readonly tokenObtainPair: TokenObtainPair
}

/**
 * Request parameters for getVerifiedToken operation in APIApi.
 * @export
 * @interface APIApiGetVerifiedTokenRequest
 */
export interface APIApiGetVerifiedTokenRequest {
    /**
     * 
     * @type {VerifiedTokenObtainPair}
     * @memberof APIApiGetVerifiedToken
     */
    readonly verifiedTokenObtainPair: VerifiedTokenObtainPair
}

/**
 * Request parameters for refreshToken operation in APIApi.
 * @export
 * @interface APIApiRefreshTokenRequest
 */
export interface APIApiRefreshTokenRequest {
    /**
     * 
     * @type {TokenRefresh}
     * @memberof APIApiRefreshToken
     */
    readonly tokenRefresh: TokenRefresh
}

/**
 * Request parameters for verifyToken operation in APIApi.
 * @export
 * @interface APIApiVerifyTokenRequest
 */
export interface APIApiVerifyTokenRequest {
    /**
     * 
     * @type {TokenVerify}
     * @memberof APIApiVerifyToken
     */
    readonly tokenVerify: TokenVerify
}

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * Authenticate the user and return a token pair
     * @summary Obtain auth token pair
     * @param {APIApiAuthenticateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public authenticate(requestParameters: APIApiAuthenticateRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).authenticate(requestParameters.tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Data References
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public data(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).data(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a verified JWT token pair by submitting a Two-Factor authentication code.
     * @summary Get verified JWT token
     * @param {APIApiGetVerifiedTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getVerifiedToken(requestParameters: APIApiGetVerifiedTokenRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).getVerifiedToken(requestParameters.verifiedTokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instance Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public ping(options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate the user and return a token pair
     * @summary Refresh auth token
     * @param {APIApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public refreshToken(requestParameters: APIApiRefreshTokenRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).refreshToken(requestParameters.tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify an existent authentication token
     * @summary Verify token
     * @param {APIApiVerifyTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public verifyToken(requestParameters: APIApiVerifyTokenRequest, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).verifyToken(requestParameters.tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (addressData: AddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressData' is not null or undefined
            assertParamExists('create', 'addressData', addressData)
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedAddressData?: PatchedAddressData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAddressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(addressData: AddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(addressData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedAddressData?: PatchedAddressData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedAddressData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(addressData: AddressData, options?: any): AxiosPromise<Address> {
            return localVarFp.create(addressData, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Address> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<AddressList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Address> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {PatchedAddressData} [patchedAddressData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, patchedAddressData?: PatchedAddressData, options?: any): AxiosPromise<Address> {
            return localVarFp.update(id, patchedAddressData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in AddressesApi.
 * @export
 * @interface AddressesApiCreateRequest
 */
export interface AddressesApiCreateRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof AddressesApiCreate
     */
    readonly addressData: AddressData
}

/**
 * Request parameters for discard operation in AddressesApi.
 * @export
 * @interface AddressesApiDiscardRequest
 */
export interface AddressesApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in AddressesApi.
 * @export
 * @interface AddressesApiRetrieveRequest
 */
export interface AddressesApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in AddressesApi.
 * @export
 * @interface AddressesApiUpdateRequest
 */
export interface AddressesApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressesApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedAddressData}
     * @memberof AddressesApiUpdate
     */
    readonly patchedAddressData?: PatchedAddressData
}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Create a new address.
     * @summary Create an address
     * @param {AddressesApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public create(requestParameters: AddressesApiCreateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).create(requestParameters.addressData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard an address.
     * @summary Discard an address
     * @param {AddressesApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public discard(requestParameters: AddressesApiDiscardRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all addresses.
     * @summary List all addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public list(options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an address.
     * @summary Retrieve an address
     * @param {AddressesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public retrieve(requestParameters: AddressesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an address.
     * @summary Update an address
     * @param {AddressesApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public update(requestParameters: AddressesApiUpdateRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedAddressData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create multiple orders in a single batch. `Beta`
         * @summary Create orders
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders: async (batchOrderData: BatchOrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchOrderData' is not null or undefined
            assertParamExists('createOrders', 'batchOrderData', batchOrderData)
            const localVarPath = `/v1/batches/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchOrderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple shipments in a single batch. `Beta`
         * @summary Create shipments
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments: async (batchShipmentData: BatchShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchShipmentData' is not null or undefined
            assertParamExists('createShipments', 'batchShipmentData', batchShipmentData)
            const localVarPath = `/v1/batches/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchShipmentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple trackers in a single batch. `Beta`
         * @summary Create trackers
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackers: async (batchTrackerData: BatchTrackerData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchTrackerData' is not null or undefined
            assertParamExists('createTrackers', 'batchTrackerData', batchTrackerData)
            const localVarPath = `/v1/batches/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchTrackerData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {'billing' | 'order' | 'shipment' | 'trackers'} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile: async (dataFile?: File, dataTemplate?: string, resourceType?: 'billing' | 'order' | 'shipment' | 'trackers', resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches/data/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (dataFile !== undefined) {
                localVarQueryParameter['data_file'] = dataFile;
            }

            if (dataTemplate !== undefined) {
                localVarQueryParameter['data_template'] = dataTemplate;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }


            if (resourceType2 !== undefined) { 
                localVarFormParams.append('resource_type', resourceType2 as any);
            }
    
            if (dataTemplate2 !== undefined) { 
                localVarFormParams.append('data_template', dataTemplate2 as any);
            }
    
            if (dataFile2 !== undefined) { 
                localVarFormParams.append('data_file', dataFile2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/batches/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/batches/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create multiple orders in a single batch. `Beta`
         * @summary Create orders
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrders(batchOrderData: BatchOrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrders(batchOrderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create multiple shipments in a single batch. `Beta`
         * @summary Create shipments
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipments(batchShipmentData: BatchShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipments(batchShipmentData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create multiple trackers in a single batch. `Beta`
         * @summary Create trackers
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrackers(batchTrackerData: BatchTrackerData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrackers(batchTrackerData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {'billing' | 'order' | 'shipment' | 'trackers'} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFile(dataFile?: File, dataTemplate?: string, resourceType?: 'billing' | 'order' | 'shipment' | 'trackers', resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFile(dataFile, dataTemplate, resourceType, resourceType2, dataTemplate2, dataFile2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchOperation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * Create multiple orders in a single batch. `Beta`
         * @summary Create orders
         * @param {BatchOrderData} batchOrderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrders(batchOrderData: BatchOrderData, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.createOrders(batchOrderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple shipments in a single batch. `Beta`
         * @summary Create shipments
         * @param {BatchShipmentData} batchShipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipments(batchShipmentData: BatchShipmentData, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.createShipments(batchShipmentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple trackers in a single batch. `Beta`
         * @summary Create trackers
         * @param {BatchTrackerData} batchTrackerData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrackers(batchTrackerData: BatchTrackerData, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.createTrackers(batchTrackerData, options).then((request) => request(axios, basePath));
        },
        /**
         * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
         * @summary Import data files
         * @param {File} [dataFile] 
         * @param {string} [dataTemplate] A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
         * @param {'billing' | 'order' | 'shipment' | 'trackers'} [resourceType] The type of the resource to import
         * @param {string} [resourceType2] 
         * @param {string} [dataTemplate2] 
         * @param {File} [dataFile2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFile(dataFile?: File, dataTemplate?: string, resourceType?: 'billing' | 'order' | 'shipment' | 'trackers', resourceType2?: string, dataTemplate2?: string, dataFile2?: File, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.importFile(dataFile, dataTemplate, resourceType, resourceType2, dataTemplate2, dataFile2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all batch operations. `Beta`
         * @summary List all batch operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<BatchOperations> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a batch operation. `Beta`
         * @summary Retrieve a batch operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<BatchOperation> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOrders operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateOrdersRequest
 */
export interface BatchesApiCreateOrdersRequest {
    /**
     * 
     * @type {BatchOrderData}
     * @memberof BatchesApiCreateOrders
     */
    readonly batchOrderData: BatchOrderData
}

/**
 * Request parameters for createShipments operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateShipmentsRequest
 */
export interface BatchesApiCreateShipmentsRequest {
    /**
     * 
     * @type {BatchShipmentData}
     * @memberof BatchesApiCreateShipments
     */
    readonly batchShipmentData: BatchShipmentData
}

/**
 * Request parameters for createTrackers operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateTrackersRequest
 */
export interface BatchesApiCreateTrackersRequest {
    /**
     * 
     * @type {BatchTrackerData}
     * @memberof BatchesApiCreateTrackers
     */
    readonly batchTrackerData: BatchTrackerData
}

/**
 * Request parameters for importFile operation in BatchesApi.
 * @export
 * @interface BatchesApiImportFileRequest
 */
export interface BatchesApiImportFileRequest {
    /**
     * 
     * @type {File}
     * @memberof BatchesApiImportFile
     */
    readonly dataFile?: File

    /**
     * A data template slug to use for the import.&lt;br/&gt;         **When nothing is specified, the system default headers are expected.**         
     * @type {string}
     * @memberof BatchesApiImportFile
     */
    readonly dataTemplate?: string

    /**
     * The type of the resource to import
     * @type {'billing' | 'order' | 'shipment' | 'trackers'}
     * @memberof BatchesApiImportFile
     */
    readonly resourceType?: 'billing' | 'order' | 'shipment' | 'trackers'

    /**
     * 
     * @type {string}
     * @memberof BatchesApiImportFile
     */
    readonly resourceType2?: string

    /**
     * 
     * @type {string}
     * @memberof BatchesApiImportFile
     */
    readonly dataTemplate2?: string

    /**
     * 
     * @type {File}
     * @memberof BatchesApiImportFile
     */
    readonly dataFile2?: File
}

/**
 * Request parameters for retrieve operation in BatchesApi.
 * @export
 * @interface BatchesApiRetrieveRequest
 */
export interface BatchesApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof BatchesApiRetrieve
     */
    readonly id: string
}

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * Create multiple orders in a single batch. `Beta`
     * @summary Create orders
     * @param {BatchesApiCreateOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createOrders(requestParameters: BatchesApiCreateOrdersRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createOrders(requestParameters.batchOrderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple shipments in a single batch. `Beta`
     * @summary Create shipments
     * @param {BatchesApiCreateShipmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createShipments(requestParameters: BatchesApiCreateShipmentsRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createShipments(requestParameters.batchShipmentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple trackers in a single batch. `Beta`
     * @summary Create trackers
     * @param {BatchesApiCreateTrackersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public createTrackers(requestParameters: BatchesApiCreateTrackersRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).createTrackers(requestParameters.batchTrackerData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import csv, xls and xlsx data files for: `Beta`<br/> - trackers data - orders data - shipments data - billing data (soon)<br/><br/> **This operation will return a batch operation that you can poll to follow the import progression.**
     * @summary Import data files
     * @param {BatchesApiImportFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public importFile(requestParameters: BatchesApiImportFileRequest = {}, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).importFile(requestParameters.dataFile, requestParameters.dataTemplate, requestParameters.resourceType, requestParameters.resourceType2, requestParameters.dataTemplate2, requestParameters.dataFile2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all batch operations. `Beta`
     * @summary List all batch operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public list(options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a batch operation. `Beta`
     * @summary Retrieve a batch operation
     * @param {BatchesApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public retrieve(requestParameters: BatchesApiRetrieveRequest, options?: AxiosRequestConfig) {
        return BatchesApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CarriersApi - axios parameter creator
 * @export
 */
export const CarriersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('getServices', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers/{carrier_name}/services`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {boolean} [action] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', action?: boolean, systemOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('list', 'carrierName', carrierName)
            const localVarPath = `/v1/carriers`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['system_only'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarriersApi - functional programming interface
 * @export
 */
export const CarriersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarriersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(carrierName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {boolean} [action] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', action?: boolean, systemOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(carrierName, action, systemOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarriersApi - factory interface
 * @export
 */
export const CarriersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarriersApiFp(configuration)
    return {
        /**
         * Retrieve a carrier\'s services
         * @summary Get carrier services
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getServices(carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {boolean} [action] 
         * @param {boolean} [systemOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', action?: boolean, systemOnly?: boolean, options?: any): AxiosPromise<CarrierList> {
            return localVarFp.list(carrierName, action, systemOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getServices operation in CarriersApi.
 * @export
 * @interface CarriersApiGetServicesRequest
 */
export interface CarriersApiGetServicesRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof CarriersApiGetServices
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'
}

/**
 * Request parameters for list operation in CarriersApi.
 * @export
 * @interface CarriersApiListRequest
 */
export interface CarriersApiListRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof CarriersApiList
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {boolean}
     * @memberof CarriersApiList
     */
    readonly action?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof CarriersApiList
     */
    readonly systemOnly?: boolean
}

/**
 * CarriersApi - object-oriented interface
 * @export
 * @class CarriersApi
 * @extends {BaseAPI}
 */
export class CarriersApi extends BaseAPI {
    /**
     * Retrieve a carrier\'s services
     * @summary Get carrier services
     * @param {CarriersApiGetServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public getServices(requestParameters: CarriersApiGetServicesRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).getServices(requestParameters.carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of configured carriers
     * @summary List all carriers
     * @param {CarriersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public list(requestParameters: CarriersApiListRequest, options?: AxiosRequestConfig) {
        return CarriersApiFp(this.configuration).list(requestParameters.carrierName, requestParameters.action, requestParameters.systemOnly, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomsApi - axios parameter creator
 * @export
 */
export const CustomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} customsData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (customsData: CustomsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customsData' is not null or undefined
            assertParamExists('create', 'customsData', customsData)
            const localVarPath = `/v1/customs_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customs_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {PatchedCustomsData} [patchedCustomsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedCustomsData?: PatchedCustomsData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomsData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomsApi - functional programming interface
 * @export
 */
export const CustomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} customsData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(customsData: CustomsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(customsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {PatchedCustomsData} [patchedCustomsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedCustomsData?: PatchedCustomsData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedCustomsData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomsApi - factory interface
 * @export
 */
export const CustomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomsApiFp(configuration)
    return {
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} customsData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(customsData: CustomsData, options?: any): AxiosPromise<Customs> {
            return localVarFp.create(customsData, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Customs> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<CustomsList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Customs> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {PatchedCustomsData} [patchedCustomsData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, patchedCustomsData?: PatchedCustomsData, options?: any): AxiosPromise<Customs> {
            return localVarFp.update(id, patchedCustomsData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in CustomsApi.
 * @export
 * @interface CustomsApiCreateRequest
 */
export interface CustomsApiCreateRequest {
    /**
     * 
     * @type {CustomsData}
     * @memberof CustomsApiCreate
     */
    readonly customsData: CustomsData
}

/**
 * Request parameters for discard operation in CustomsApi.
 * @export
 * @interface CustomsApiDiscardRequest
 */
export interface CustomsApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomsApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in CustomsApi.
 * @export
 * @interface CustomsApiRetrieveRequest
 */
export interface CustomsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in CustomsApi.
 * @export
 * @interface CustomsApiUpdateRequest
 */
export interface CustomsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedCustomsData}
     * @memberof CustomsApiUpdate
     */
    readonly patchedCustomsData?: PatchedCustomsData
}

/**
 * CustomsApi - object-oriented interface
 * @export
 * @class CustomsApi
 * @extends {BaseAPI}
 */
export class CustomsApi extends BaseAPI {
    /**
     * Create a new customs declaration.
     * @summary Create a customs info
     * @param {CustomsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public create(requestParameters: CustomsApiCreateRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).create(requestParameters.customsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a customs declaration.
     * @summary Discard a customs info
     * @param {CustomsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public discard(requestParameters: CustomsApiDiscardRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored customs declarations.
     * @summary List all customs info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public list(options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve customs declaration.
     * @summary Retrieve a customs info
     * @param {CustomsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public retrieve(requestParameters: CustomsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing customs declaration.
     * @summary Update a customs info
     * @param {CustomsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public update(requestParameters: CustomsApiUpdateRequest, options?: AxiosRequestConfig) {
        return CustomsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedCustomsData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve an upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (documentUploadData: DocumentUploadData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentUploadData' is not null or undefined
            assertParamExists('upload', 'documentUploadData', documentUploadData)
            const localVarPath = `/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUploadData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecords>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve an upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(documentUploadData: DocumentUploadData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(documentUploadData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Retrieve all shipping document upload records.
         * @summary List all upload records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<DocumentUploadRecords> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipping document upload record.
         * @summary Retrieve an upload record
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a shipping document.
         * @summary Upload documents
         * @param {DocumentUploadData} documentUploadData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(documentUploadData: DocumentUploadData, options?: any): AxiosPromise<DocumentUploadRecord> {
            return localVarFp.upload(documentUploadData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for retrieve operation in DocumentsApi.
 * @export
 * @interface DocumentsApiRetrieveRequest
 */
export interface DocumentsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for upload operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadRequest
 */
export interface DocumentsApiUploadRequest {
    /**
     * 
     * @type {DocumentUploadData}
     * @memberof DocumentsApiUpload
     */
    readonly documentUploadData: DocumentUploadData
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Retrieve all shipping document upload records.
     * @summary List all upload records
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public list(options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipping document upload record.
     * @summary Retrieve an upload record
     * @param {DocumentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public retrieve(requestParameters: DocumentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a shipping document.
     * @summary Upload documents
     * @param {DocumentsApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public upload(requestParameters: DocumentsApiUploadRequest, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).upload(requestParameters.documentUploadData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (orderData: OrderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderData' is not null or undefined
            assertParamExists('create', 'orderData', orderData)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, orderUpdateData?: OrderUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(orderData: OrderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(orderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, orderUpdateData?: OrderUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, orderUpdateData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Cancel an order.
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, options?: any): AxiosPromise<Order> {
            return localVarFp.cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order object.
         * @summary Create an order
         * @param {OrderData} orderData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(orderData: OrderData, options?: any): AxiosPromise<Order> {
            return localVarFp.create(orderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders.
         * @summary List all orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<OrderList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an order.
         * @summary Retrieve an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Order> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
         * @summary Update an order
         * @param {string} id 
         * @param {OrderUpdateData} [orderUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, orderUpdateData?: OrderUpdateData, options?: any): AxiosPromise<Order> {
            return localVarFp.update(id, orderUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in OrdersApi.
 * @export
 * @interface OrdersApiCancelRequest
 */
export interface OrdersApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for create operation in OrdersApi.
 * @export
 * @interface OrdersApiCreateRequest
 */
export interface OrdersApiCreateRequest {
    /**
     * 
     * @type {OrderData}
     * @memberof OrdersApiCreate
     */
    readonly orderData: OrderData
}

/**
 * Request parameters for retrieve operation in OrdersApi.
 * @export
 * @interface OrdersApiRetrieveRequest
 */
export interface OrdersApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in OrdersApi.
 * @export
 * @interface OrdersApiUpdateRequest
 */
export interface OrdersApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrdersApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {OrderUpdateData}
     * @memberof OrdersApiUpdate
     */
    readonly orderUpdateData?: OrderUpdateData
}

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Cancel an order.
     * @summary Cancel an order
     * @param {OrdersApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public cancel(requestParameters: OrdersApiCancelRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order object.
     * @summary Create an order
     * @param {OrdersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public create(requestParameters: OrdersApiCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).create(requestParameters.orderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders.
     * @summary List all orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public list(options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an order.
     * @summary Retrieve an order
     * @param {OrdersApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public retrieve(requestParameters: OrdersApiRetrieveRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of an order including `options` and `metadata`. It is not for editing the line items of an order.
     * @summary Update an order
     * @param {OrdersApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public update(requestParameters: OrdersApiUpdateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).update(requestParameters.id, requestParameters.orderUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParcelsApi - axios parameter creator
 * @export
 */
export const ParcelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (parcelData: ParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parcelData' is not null or undefined
            assertParamExists('create', 'parcelData', parcelData)
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedParcelData?: PatchedParcelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedParcelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParcelsApi - functional programming interface
 * @export
 */
export const ParcelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParcelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(parcelData: ParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(parcelData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedParcelData?: PatchedParcelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedParcelData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParcelsApi - factory interface
 * @export
 */
export const ParcelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParcelsApiFp(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} parcelData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(parcelData: ParcelData, options?: any): AxiosPromise<Parcel> {
            return localVarFp.create(parcelData, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Parcel> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<ParcelList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Parcel> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {PatchedParcelData} [patchedParcelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, patchedParcelData?: PatchedParcelData, options?: any): AxiosPromise<Parcel> {
            return localVarFp.update(id, patchedParcelData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in ParcelsApi.
 * @export
 * @interface ParcelsApiCreateRequest
 */
export interface ParcelsApiCreateRequest {
    /**
     * 
     * @type {ParcelData}
     * @memberof ParcelsApiCreate
     */
    readonly parcelData: ParcelData
}

/**
 * Request parameters for discard operation in ParcelsApi.
 * @export
 * @interface ParcelsApiDiscardRequest
 */
export interface ParcelsApiDiscardRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiDiscard
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in ParcelsApi.
 * @export
 * @interface ParcelsApiRetrieveRequest
 */
export interface ParcelsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ParcelsApi.
 * @export
 * @interface ParcelsApiUpdateRequest
 */
export interface ParcelsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ParcelsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedParcelData}
     * @memberof ParcelsApiUpdate
     */
    readonly patchedParcelData?: PatchedParcelData
}

/**
 * ParcelsApi - object-oriented interface
 * @export
 * @class ParcelsApi
 * @extends {BaseAPI}
 */
export class ParcelsApi extends BaseAPI {
    /**
     * Create a new parcel.
     * @summary Create a parcel
     * @param {ParcelsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public create(requestParameters: ParcelsApiCreateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).create(requestParameters.parcelData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a parcel.
     * @summary Remove a parcel
     * @param {ParcelsApiDiscardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public discard(requestParameters: ParcelsApiDiscardRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).discard(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored parcels.
     * @summary List all parcels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public list(options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a parcel.
     * @summary Retrieve a parcel
     * @param {ParcelsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public retrieve(requestParameters: ParcelsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing parcel\'s details.
     * @summary Update a parcel
     * @param {ParcelsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public update(requestParameters: ParcelsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ParcelsApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedParcelData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PickupsApi - axios parameter creator
 * @export
 */
export const PickupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, pickupCancelData?: PickupCancelData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/pickups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupCancelData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule: async (carrierName: string, pickupData: PickupData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedule', 'carrierName', carrierName)
            // verify required parameter 'pickupData' is not null or undefined
            assertParamExists('schedule', 'pickupData', pickupData)
            const localVarPath = `/v1/pickups/{carrier_name}/schedule`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, pickupUpdateData: PickupUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'pickupUpdateData' is not null or undefined
            assertParamExists('update', 'pickupUpdateData', pickupUpdateData)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PickupsApi - functional programming interface
 * @export
 */
export const PickupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PickupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, pickupCancelData?: PickupCancelData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, pickupCancelData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedule(carrierName: string, pickupData: PickupData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedule(carrierName, pickupData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, pickupUpdateData: PickupUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, pickupUpdateData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PickupsApi - factory interface
 * @export
 */
export const PickupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PickupsApiFp(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} [pickupCancelData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, pickupCancelData?: PickupCancelData, options?: any): AxiosPromise<Pickup> {
            return localVarFp.cancel(id, pickupCancelData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<PickupList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Pickup> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} pickupData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule(carrierName: string, pickupData: PickupData, options?: any): AxiosPromise<Pickup> {
            return localVarFp.schedule(carrierName, pickupData, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} pickupUpdateData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, pickupUpdateData: PickupUpdateData, options?: any): AxiosPromise<Pickup> {
            return localVarFp.update(id, pickupUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in PickupsApi.
 * @export
 * @interface PickupsApiCancelRequest
 */
export interface PickupsApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiCancel
     */
    readonly id: string

    /**
     * 
     * @type {PickupCancelData}
     * @memberof PickupsApiCancel
     */
    readonly pickupCancelData?: PickupCancelData
}

/**
 * Request parameters for retrieve operation in PickupsApi.
 * @export
 * @interface PickupsApiRetrieveRequest
 */
export interface PickupsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for schedule operation in PickupsApi.
 * @export
 * @interface PickupsApiScheduleRequest
 */
export interface PickupsApiScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiSchedule
     */
    readonly carrierName: string

    /**
     * 
     * @type {PickupData}
     * @memberof PickupsApiSchedule
     */
    readonly pickupData: PickupData
}

/**
 * Request parameters for update operation in PickupsApi.
 * @export
 * @interface PickupsApiUpdateRequest
 */
export interface PickupsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PickupsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PickupUpdateData}
     * @memberof PickupsApiUpdate
     */
    readonly pickupUpdateData: PickupUpdateData
}

/**
 * PickupsApi - object-oriented interface
 * @export
 * @class PickupsApi
 * @extends {BaseAPI}
 */
export class PickupsApi extends BaseAPI {
    /**
     * Cancel a pickup of one or more shipments.
     * @summary Cancel a pickup
     * @param {PickupsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public cancel(requestParameters: PickupsApiCancelRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).cancel(requestParameters.id, requestParameters.pickupCancelData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all scheduled pickups.
     * @summary List shipment pickups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public list(options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a scheduled pickup.
     * @summary Retrieve a pickup
     * @param {PickupsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public retrieve(requestParameters: PickupsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a pickup for one or many shipments with labels already purchased.
     * @summary Schedule a pickup
     * @param {PickupsApiScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public schedule(requestParameters: PickupsApiScheduleRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).schedule(requestParameters.carrierName, requestParameters.pickupData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a pickup for one or many shipments with labels already purchased.
     * @summary Update a pickup
     * @param {PickupsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public update(requestParameters: PickupsApiUpdateRequest, options?: AxiosRequestConfig) {
        return PickupsApiFp(this.configuration).update(requestParameters.id, requestParameters.pickupUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel: async (shippingRequest: ShippingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingRequest' is not null or undefined
            assertParamExists('buyLabel', 'shippingRequest', shippingRequest)
            const localVarPath = `/v1/proxy/shipping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupCancelRequest: PickupCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('cancelPickup', 'carrierName', carrierName)
            // verify required parameter 'pickupCancelRequest' is not null or undefined
            assertParamExists('cancelPickup', 'pickupCancelRequest', pickupCancelRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates: async (rateRequest: RateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateRequest' is not null or undefined
            assertParamExists('fetchRates', 'rateRequest', rateRequest)
            const localVarPath = `/v1/proxy/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracking: async (trackingData: TrackingData, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingData' is not null or undefined
            assertParamExists('getTracking', 'trackingData', trackingData)
            const localVarPath = `/v1/proxy/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupRequest: PickupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedulePickup', 'carrierName', carrierName)
            // verify required parameter 'pickupRequest' is not null or undefined
            assertParamExists('schedulePickup', 'pickupRequest', pickupRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        trackShipment: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', trackingNumber: string, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('trackShipment', 'carrierName', carrierName)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('trackShipment', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/proxy/tracking/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupUpdateRequest: PickupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('updatePickup', 'carrierName', carrierName)
            // verify required parameter 'pickupUpdateRequest' is not null or undefined
            assertParamExists('updatePickup', 'pickupUpdateRequest', pickupUpdateRequest)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/update`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: async (carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', shipmentCancelRequest: ShipmentCancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('voidLabel', 'carrierName', carrierName)
            // verify required parameter 'shipmentCancelRequest' is not null or undefined
            assertParamExists('voidLabel', 'shipmentCancelRequest', shipmentCancelRequest)
            const localVarPath = `/v1/proxy/shipping/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentCancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buyLabel(shippingRequest: ShippingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buyLabel(shippingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupCancelRequest: PickupCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPickup(carrierName, pickupCancelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRates(rateRequest: RateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRates(rateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTracking(trackingData: TrackingData, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTracking(trackingData, hub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupRequest: PickupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePickup(carrierName, pickupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async trackShipment(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', trackingNumber: string, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackShipment(carrierName, trackingNumber, hub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupUpdateRequest: PickupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePickup(carrierName, pickupUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidLabel(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', shipmentCancelRequest: ShipmentCancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidLabel(carrierName, shipmentCancelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} shippingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel(shippingRequest: ShippingRequest, options?: any): AxiosPromise<ShippingResponse> {
            return localVarFp.buyLabel(shippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupCancelRequest} pickupCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupCancelRequest: PickupCancelRequest, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.cancelPickup(carrierName, pickupCancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates(rateRequest: RateRequest, options?: any): AxiosPromise<RateResponse> {
            return localVarFp.fetchRates(rateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Get tracking details
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracking(trackingData: TrackingData, hub?: string, options?: any): AxiosPromise<TrackingResponse> {
            return localVarFp.getTracking(trackingData, hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupRequest} pickupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupRequest: PickupRequest, options?: any): AxiosPromise<PickupResponse> {
            return localVarFp.schedulePickup(carrierName, pickupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        trackShipment(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', trackingNumber: string, hub?: string, options?: any): AxiosPromise<TrackingResponse> {
            return localVarFp.trackShipment(carrierName, trackingNumber, hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {PickupUpdateRequest} pickupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', pickupUpdateRequest: PickupUpdateRequest, options?: any): AxiosPromise<PickupResponse> {
            return localVarFp.updatePickup(carrierName, pickupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName 
         * @param {ShipmentCancelRequest} shipmentCancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', shipmentCancelRequest: ShipmentCancelRequest, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.voidLabel(carrierName, shipmentCancelRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for buyLabel operation in ProxyApi.
 * @export
 * @interface ProxyApiBuyLabelRequest
 */
export interface ProxyApiBuyLabelRequest {
    /**
     * 
     * @type {ShippingRequest}
     * @memberof ProxyApiBuyLabel
     */
    readonly shippingRequest: ShippingRequest
}

/**
 * Request parameters for cancelPickup operation in ProxyApi.
 * @export
 * @interface ProxyApiCancelPickupRequest
 */
export interface ProxyApiCancelPickupRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiCancelPickup
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {PickupCancelRequest}
     * @memberof ProxyApiCancelPickup
     */
    readonly pickupCancelRequest: PickupCancelRequest
}

/**
 * Request parameters for fetchRates operation in ProxyApi.
 * @export
 * @interface ProxyApiFetchRatesRequest
 */
export interface ProxyApiFetchRatesRequest {
    /**
     * 
     * @type {RateRequest}
     * @memberof ProxyApiFetchRates
     */
    readonly rateRequest: RateRequest
}

/**
 * Request parameters for getTracking operation in ProxyApi.
 * @export
 * @interface ProxyApiGetTrackingRequest
 */
export interface ProxyApiGetTrackingRequest {
    /**
     * 
     * @type {TrackingData}
     * @memberof ProxyApiGetTracking
     */
    readonly trackingData: TrackingData

    /**
     * 
     * @type {string}
     * @memberof ProxyApiGetTracking
     */
    readonly hub?: string
}

/**
 * Request parameters for schedulePickup operation in ProxyApi.
 * @export
 * @interface ProxyApiSchedulePickupRequest
 */
export interface ProxyApiSchedulePickupRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiSchedulePickup
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {PickupRequest}
     * @memberof ProxyApiSchedulePickup
     */
    readonly pickupRequest: PickupRequest
}

/**
 * Request parameters for trackShipment operation in ProxyApi.
 * @export
 * @interface ProxyApiTrackShipmentRequest
 */
export interface ProxyApiTrackShipmentRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiTrackShipment
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {string}
     * @memberof ProxyApiTrackShipment
     */
    readonly trackingNumber: string

    /**
     * 
     * @type {string}
     * @memberof ProxyApiTrackShipment
     */
    readonly hub?: string
}

/**
 * Request parameters for updatePickup operation in ProxyApi.
 * @export
 * @interface ProxyApiUpdatePickupRequest
 */
export interface ProxyApiUpdatePickupRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiUpdatePickup
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {PickupUpdateRequest}
     * @memberof ProxyApiUpdatePickup
     */
    readonly pickupUpdateRequest: PickupUpdateRequest
}

/**
 * Request parameters for voidLabel operation in ProxyApi.
 * @export
 * @interface ProxyApiVoidLabelRequest
 */
export interface ProxyApiVoidLabelRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ProxyApiVoidLabel
     */
    readonly carrierName: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {ShipmentCancelRequest}
     * @memberof ProxyApiVoidLabel
     */
    readonly shipmentCancelRequest: ShipmentCancelRequest
}

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * @summary Buy a shipment label
     * @param {ProxyApiBuyLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public buyLabel(requestParameters: ProxyApiBuyLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).buyLabel(requestParameters.shippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a pickup previously scheduled
     * @summary Cancel a pickup
     * @param {ProxyApiCancelPickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public cancelPickup(requestParameters: ProxyApiCancelPickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).cancelPickup(requestParameters.carrierName, requestParameters.pickupCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * @summary Fetch shipment rates
     * @param {ProxyApiFetchRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public fetchRates(requestParameters: ProxyApiFetchRatesRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).fetchRates(requestParameters.rateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Get tracking details
     * @param {ProxyApiGetTrackingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public getTracking(requestParameters: ProxyApiGetTrackingRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).getTracking(requestParameters.trackingData, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule one or many parcels pickup
     * @summary Schedule a pickup
     * @param {ProxyApiSchedulePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public schedulePickup(requestParameters: ProxyApiSchedulePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).schedulePickup(requestParameters.carrierName, requestParameters.pickupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Track a shipment
     * @param {ProxyApiTrackShipmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public trackShipment(requestParameters: ProxyApiTrackShipmentRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).trackShipment(requestParameters.carrierName, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a scheduled pickup
     * @summary Update a pickup
     * @param {ProxyApiUpdatePickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public updatePickup(requestParameters: ProxyApiUpdatePickupRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).updatePickup(requestParameters.carrierName, requestParameters.pickupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a shipment and the label previously created
     * @summary Void a shipment label
     * @param {ProxyApiVoidLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public voidLabel(requestParameters: ProxyApiVoidLabelRequest, options?: AxiosRequestConfig) {
        return ProxyApiFp(this.configuration).voidLabel(requestParameters.carrierName, requestParameters.shipmentCancelRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
export const ShipmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (shipmentData: ShipmentData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentData' is not null or undefined
            assertParamExists('create', 'shipmentData', shipmentData)
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] 
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [keyword] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped'} [status] 
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (address?: string, carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', createdAfter?: string, createdBefore?: string, keyword?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: 'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped', trackingNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (metadataKey !== undefined) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }

            if (metadataValue !== undefined) {
                localVarQueryParameter['metadata_value'] = metadataValue;
            }

            if (optionKey !== undefined) {
                localVarQueryParameter['option_key'] = optionKey;
            }

            if (optionValue !== undefined) {
                localVarQueryParameter['option_value'] = optionValue;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (id: string, shipmentPurchaseData: ShipmentPurchaseData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchase', 'id', id)
            // verify required parameter 'shipmentPurchaseData' is not null or undefined
            assertParamExists('purchase', 'shipmentPurchaseData', shipmentPurchaseData)
            const localVarPath = `/v1/shipments/{id}/purchase`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentPurchaseData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates: async (id: string, shipmentRateData?: ShipmentRateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rates', 'id', id)
            const localVarPath = `/v1/shipments/{id}/rates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentRateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, shipmentUpdateData?: ShipmentUpdateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shipmentUpdateData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipmentsApi - functional programming interface
 * @export
 */
export const ShipmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShipmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(shipmentData: ShipmentData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(shipmentData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] 
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [keyword] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped'} [status] 
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(address?: string, carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', createdAfter?: string, createdBefore?: string, keyword?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: 'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped', trackingNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(address, carrierName, createdAfter, createdBefore, keyword, metadataKey, metadataValue, optionKey, optionValue, reference, service, status, trackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(id: string, shipmentPurchaseData: ShipmentPurchaseData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(id, shipmentPurchaseData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rates(id: string, shipmentRateData?: ShipmentRateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rates(id, shipmentRateData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, shipmentUpdateData?: ShipmentUpdateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, shipmentUpdateData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShipmentsApi - factory interface
 * @export
 */
export const ShipmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShipmentsApiFp(configuration)
    return {
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, options?: any): AxiosPromise<Shipment> {
            return localVarFp.cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} shipmentData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(shipmentData: ShipmentData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.create(shipmentData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {string} [address] 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] 
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {string} [keyword] 
         * @param {string} [metadataKey] 
         * @param {string} [metadataValue] 
         * @param {string} [optionKey] 
         * @param {string} [optionValue] 
         * @param {string} [reference] 
         * @param {string} [service] 
         * @param {'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped'} [status] 
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(address?: string, carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', createdAfter?: string, createdBefore?: string, keyword?: string, metadataKey?: string, metadataValue?: string, optionKey?: string, optionValue?: string, reference?: string, service?: string, status?: 'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped', trackingNumber?: string, options?: any): AxiosPromise<ShipmentList> {
            return localVarFp.list(address, carrierName, createdAfter, createdBefore, keyword, metadataKey, metadataValue, optionKey, optionValue, reference, service, status, trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} shipmentPurchaseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(id: string, shipmentPurchaseData: ShipmentPurchaseData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.purchase(id, shipmentPurchaseData, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} [shipmentRateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates(id: string, shipmentRateData?: ShipmentRateData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.rates(id, shipmentRateData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Shipment> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
         * @summary Update a shipment
         * @param {string} id 
         * @param {ShipmentUpdateData} [shipmentUpdateData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, shipmentUpdateData?: ShipmentUpdateData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.update(id, shipmentUpdateData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiCancelRequest
 */
export interface ShipmentsApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for create operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiCreateRequest
 */
export interface ShipmentsApiCreateRequest {
    /**
     * 
     * @type {ShipmentData}
     * @memberof ShipmentsApiCreate
     */
    readonly shipmentData: ShipmentData
}

/**
 * Request parameters for list operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiListRequest
 */
export interface ShipmentsApiListRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly address?: string

    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof ShipmentsApiList
     */
    readonly carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly createdAfter?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly createdBefore?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly keyword?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metadataKey?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly metadataValue?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly optionKey?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly optionValue?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly reference?: string

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly service?: string

    /**
     * 
     * @type {'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped'}
     * @memberof ShipmentsApiList
     */
    readonly status?: 'cancelled' | 'delivered' | 'draft' | 'in_transit' | 'purchased' | 'shipped'

    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiList
     */
    readonly trackingNumber?: string
}

/**
 * Request parameters for purchase operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiPurchaseRequest
 */
export interface ShipmentsApiPurchaseRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiPurchase
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentPurchaseData}
     * @memberof ShipmentsApiPurchase
     */
    readonly shipmentPurchaseData: ShipmentPurchaseData
}

/**
 * Request parameters for rates operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiRatesRequest
 */
export interface ShipmentsApiRatesRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiRates
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentRateData}
     * @memberof ShipmentsApiRates
     */
    readonly shipmentRateData?: ShipmentRateData
}

/**
 * Request parameters for retrieve operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiRetrieveRequest
 */
export interface ShipmentsApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for update operation in ShipmentsApi.
 * @export
 * @interface ShipmentsApiUpdateRequest
 */
export interface ShipmentsApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ShipmentsApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {ShipmentUpdateData}
     * @memberof ShipmentsApiUpdate
     */
    readonly shipmentUpdateData?: ShipmentUpdateData
}

/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Void a shipment with the associated label.
     * @summary Cancel a shipment
     * @param {ShipmentsApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public cancel(requestParameters: ShipmentsApiCancelRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipment instance.
     * @summary Create a shipment
     * @param {ShipmentsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public create(requestParameters: ShipmentsApiCreateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).create(requestParameters.shipmentData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipments.
     * @summary List all shipments
     * @param {ShipmentsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public list(requestParameters: ShipmentsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).list(requestParameters.address, requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.keyword, requestParameters.metadataKey, requestParameters.metadataValue, requestParameters.optionKey, requestParameters.optionValue, requestParameters.reference, requestParameters.service, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select your preferred rates to buy a shipment label.
     * @summary Buy a shipment label
     * @param {ShipmentsApiPurchaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public purchase(requestParameters: ShipmentsApiPurchaseRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).purchase(requestParameters.id, requestParameters.shipmentPurchaseData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh the list of the shipment rates
     * @summary Fetch new shipment rates
     * @param {ShipmentsApiRatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public rates(requestParameters: ShipmentsApiRatesRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).rates(requestParameters.id, requestParameters.shipmentRateData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment.
     * @summary Retrieve a shipment
     * @param {ShipmentsApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public retrieve(requestParameters: ShipmentsApiRetrieveRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows for updating properties of a shipment including `label_type`, `reference`, `payment`, `options` and `metadata`. It is not for editing the parcels of a shipment.
     * @summary Update a shipment
     * @param {ShipmentsApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public update(requestParameters: ShipmentsApiUpdateRequest, options?: AxiosRequestConfig) {
        return ShipmentsApiFp(this.configuration).update(requestParameters.id, requestParameters.shipmentUpdateData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackersApi - axios parameter creator
 * @export
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (trackingData: TrackingData, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingData' is not null or undefined
            assertParamExists('add', 'trackingData', trackingData)
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        create: async (carrierName: string, carrierName2: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', trackingNumber: string, hub?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('create', 'carrierName', carrierName)
            // verify required parameter 'carrierName2' is not null or undefined
            assertParamExists('create', 'carrierName2', carrierName2)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('create', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/trackers/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (carrierName2 !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName2;
            }

            if (hub !== undefined) {
                localVarQueryParameter['hub'] = hub;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] 
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown'} [status] 
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', createdAfter?: string, createdBefore?: string, status?: 'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown', trackingNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('remove', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieves: async (idOrTrackingNumber: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('retrieves', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 * @export
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(trackingData: TrackingData, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(trackingData, hub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async create(carrierName: string, carrierName2: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', trackingNumber: string, hub?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(carrierName, carrierName2, trackingNumber, hub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] 
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown'} [status] 
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', createdAfter?: string, createdBefore?: string, status?: 'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown', trackingNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(carrierName, createdAfter, createdBefore, status, trackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(idOrTrackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieves(idOrTrackingNumber: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieves(idOrTrackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackersApi - factory interface
 * @export
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Add a package tracker
         * @param {TrackingData} trackingData 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(trackingData: TrackingData, hub?: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.add(trackingData, hub, options).then((request) => request(axios, basePath));
        },
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a package tracker
         * @param {string} carrierName 
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} carrierName2 
         * @param {string} trackingNumber 
         * @param {string} [hub] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        create(carrierName: string, carrierName2: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', trackingNumber: string, hub?: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.create(carrierName, carrierName2, trackingNumber, hub, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all package trackers
         * @param {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] 
         * @param {string} [createdAfter] 
         * @param {string} [createdBefore] 
         * @param {'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown'} [status] 
         * @param {string} [trackingNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', createdAfter?: string, createdBefore?: string, status?: 'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown', trackingNumber?: string, options?: any): AxiosPromise<TrackerList> {
            return localVarFp.list(carrierName, createdAfter, createdBefore, status, trackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a package tracker.
         * @summary Discard a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(idOrTrackingNumber: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.remove(idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a package tracker
         * @summary Retrieves a package tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieves(idOrTrackingNumber: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.retrieves(idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for add operation in TrackersApi.
 * @export
 * @interface TrackersApiAddRequest
 */
export interface TrackersApiAddRequest {
    /**
     * 
     * @type {TrackingData}
     * @memberof TrackersApiAdd
     */
    readonly trackingData: TrackingData

    /**
     * 
     * @type {string}
     * @memberof TrackersApiAdd
     */
    readonly hub?: string
}

/**
 * Request parameters for create operation in TrackersApi.
 * @export
 * @interface TrackersApiCreateRequest
 */
export interface TrackersApiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly carrierName: string

    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof TrackersApiCreate
     */
    readonly carrierName2: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'fedex' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly trackingNumber: string

    /**
     * 
     * @type {string}
     * @memberof TrackersApiCreate
     */
    readonly hub?: string
}

/**
 * Request parameters for list operation in TrackersApi.
 * @export
 * @interface TrackersApiListRequest
 */
export interface TrackersApiListRequest {
    /**
     * 
     * @type {'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'}
     * @memberof TrackersApiList
     */
    readonly carrierName?: 'amazon_mws' | 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'chronopost' | 'dhl_express' | 'dhl_poland' | 'dhl_universal' | 'dicom' | 'dpdhl' | 'easypost' | 'eshipper' | 'fedex' | 'freightcom' | 'generic' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'ups_freight' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'

    /**
     * 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly createdAfter?: string

    /**
     * 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly createdBefore?: string

    /**
     * 
     * @type {'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown'}
     * @memberof TrackersApiList
     */
    readonly status?: 'delivered' | 'in_transit' | 'incident' | 'pending' | 'unknown'

    /**
     * 
     * @type {string}
     * @memberof TrackersApiList
     */
    readonly trackingNumber?: string
}

/**
 * Request parameters for remove operation in TrackersApi.
 * @export
 * @interface TrackersApiRemoveRequest
 */
export interface TrackersApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiRemove
     */
    readonly idOrTrackingNumber: string
}

/**
 * Request parameters for retrieves operation in TrackersApi.
 * @export
 * @interface TrackersApiRetrievesRequest
 */
export interface TrackersApiRetrievesRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackersApiRetrieves
     */
    readonly idOrTrackingNumber: string
}

/**
 * TrackersApi - object-oriented interface
 * @export
 * @class TrackersApi
 * @extends {BaseAPI}
 */
export class TrackersApi extends BaseAPI {
    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Add a package tracker
     * @param {TrackersApiAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public add(requestParameters: TrackersApiAddRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).add(requestParameters.trackingData, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Create a package tracker
     * @param {TrackersApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public create(requestParameters: TrackersApiCreateRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).create(requestParameters.carrierName, requestParameters.carrierName2, requestParameters.trackingNumber, requestParameters.hub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipment trackers.
     * @summary List all package trackers
     * @param {TrackersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public list(requestParameters: TrackersApiListRequest = {}, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).list(requestParameters.carrierName, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.status, requestParameters.trackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a package tracker.
     * @summary Discard a package tracker
     * @param {TrackersApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public remove(requestParameters: TrackersApiRemoveRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).remove(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a package tracker
     * @summary Retrieves a package tracker
     * @param {TrackersApiRetrievesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public retrieves(requestParameters: TrackersApiRetrievesRequest, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).retrieves(requestParameters.idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (webhookData: WebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookData' is not null or undefined
            assertParamExists('create', 'webhookData', webhookData)
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (id: string, webhookTestRequest: WebhookTestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('test', 'id', id)
            // verify required parameter 'webhookTestRequest' is not null or undefined
            assertParamExists('test', 'webhookTestRequest', webhookTestRequest)
            const localVarPath = `/v1/webhooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, patchedWebhookData?: PatchedWebhookData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication TokenBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebhookData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(webhookData: WebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(webhookData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(id: string, webhookTestRequest: WebhookTestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(id, webhookTestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, patchedWebhookData?: PatchedWebhookData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, patchedWebhookData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} webhookData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(webhookData: WebhookData, options?: any): AxiosPromise<Webhook> {
            return localVarFp.create(webhookData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<WebhookList> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.remove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} webhookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(id: string, webhookTestRequest: WebhookTestRequest, options?: any): AxiosPromise<Operation> {
            return localVarFp.test(id, webhookTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {PatchedWebhookData} [patchedWebhookData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, patchedWebhookData?: PatchedWebhookData, options?: any): AxiosPromise<Webhook> {
            return localVarFp.update(id, patchedWebhookData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in WebhooksApi.
 * @export
 * @interface WebhooksApiCreateRequest
 */
export interface WebhooksApiCreateRequest {
    /**
     * 
     * @type {WebhookData}
     * @memberof WebhooksApiCreate
     */
    readonly webhookData: WebhookData
}

/**
 * Request parameters for remove operation in WebhooksApi.
 * @export
 * @interface WebhooksApiRemoveRequest
 */
export interface WebhooksApiRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiRemove
     */
    readonly id: string
}

/**
 * Request parameters for retrieve operation in WebhooksApi.
 * @export
 * @interface WebhooksApiRetrieveRequest
 */
export interface WebhooksApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiRetrieve
     */
    readonly id: string
}

/**
 * Request parameters for test operation in WebhooksApi.
 * @export
 * @interface WebhooksApiTestRequest
 */
export interface WebhooksApiTestRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiTest
     */
    readonly id: string

    /**
     * 
     * @type {WebhookTestRequest}
     * @memberof WebhooksApiTest
     */
    readonly webhookTestRequest: WebhookTestRequest
}

/**
 * Request parameters for update operation in WebhooksApi.
 * @export
 * @interface WebhooksApiUpdateRequest
 */
export interface WebhooksApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {PatchedWebhookData}
     * @memberof WebhooksApiUpdate
     */
    readonly patchedWebhookData?: PatchedWebhookData
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook.
     * @summary Create a webhook
     * @param {WebhooksApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public create(requestParameters: WebhooksApiCreateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).create(requestParameters.webhookData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all webhooks.
     * @summary List all webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public list(options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a webhook.
     * @summary Remove a webhook
     * @param {WebhooksApiRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public remove(requestParameters: WebhooksApiRemoveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).remove(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a webhook.
     * @summary Retrieve a webhook
     * @param {WebhooksApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public retrieve(requestParameters: WebhooksApiRetrieveRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * test a webhook.
     * @summary Test a webhook
     * @param {WebhooksApiTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public test(requestParameters: WebhooksApiTestRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).test(requestParameters.id, requestParameters.webhookTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a webhook.
     * @summary Update a webhook
     * @param {WebhooksApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public update(requestParameters: WebhooksApiUpdateRequest, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).update(requestParameters.id, requestParameters.patchedWebhookData, options).then((request) => request(this.axios, this.basePath));
    }
}


